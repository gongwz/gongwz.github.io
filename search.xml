<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[并发编程之多进程]]></title>
    <url>%2Fposts%2Fe80a480d%2F</url>
    <content type="text"><![CDATA[Python目录并发编程之多进程并发编程之多线程并发编程之协程并发编程之IO模型僵尸进程与孤儿进程本章简介操作系统简介操作系统的作用多道技术进程理论程序与进程并发与并行进程的创建进程的终止进程的层次结构进程的状态进程并发的实现开启进程的两种方式multiprocessing模块介绍Process类的介绍Process类的使用:创建并开启子进程Process对象的join方法Process对象的其他方法或属性守护进程互斥锁模拟抢票互斥锁与join互斥锁小结队列生产者消费者模型生产者消费者模型介绍生产者消费者模型实现生产者消费者模型总结操作系统简介操作系统的作用隐藏丑陋复杂的硬件接口，提供良好的抽象接口管理、调度进程，并且将多个进程对硬件的竞争变得有序多道技术产生背景：针对单核，实现并发现在的主机一般是多核，那么每个核都会利用多道技术有4个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到4个cpu中的任意一个，具体由操作系统调度算法决定。空间上的复用：如内存中同时有多道程序时间上的复用：复用一个cpu的时间片强调：遇到io切，占用cpu时间过长也切，核心在于切之前将进程的状态保存下来，这样才能保证下次切换回来时，能基于上次切走的位置继续运行并发：看起来像同时进行的（cpu的切换速度非常快）并行：多核，真正意义上的同时进行进程理论程序与进程程序就是一堆代码进程即正在执行的一个过程，进程是对正在运行程序的一个抽象,而负责执行任务的则是 cpu进程的概念起源于操作系统，是操作系统最核心的概念，也是操作系统最重要的抽象概念之一。操作系统的其他所有内容都是围绕着进程的概念展开的。并发与并行无论并行还是并发，在用户看来都是“同时”运行的，不管是进程还是线程，都只是一个任务而已，真正活的是 cpu ，cpu来做这些任务，而一个cpu同一时刻只能执行一个任务：并发:是伪并行，即看起来像是“同时”运行的，单核（单个cpu） + 多道技术就可以实现并发并行:同时运行，只有具备多个CPU才能实现并行。单核下，可以利用多道技术，多个核，每个核也都可以利用多道技术（多道技术是针对单核而言）进程的创建但凡是硬件，都需要有操作系统去管理，只要有操作系统，就有进程的概念，就需要有创建进程的方式，一些操作系统只为了一个应用程序设计，这类系统一旦启动所有的进程就都已经存在。而对于通用型系统（跑多个应用程序），需要有系统运行过程中创建或者撤销进程的能力。主要分为下面四种形式创建新进程。系统初始化一个进程在运行过程中开启了子进程用户的交互式请求，而创建的一个新进程一个批处理作业的初始化（只在大型机的批处理系统中应用）无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的：在UNIX中该系统调用是：fork，fork会创建一个与父进程一模一样的副本，二者有相同的存储映像、同样的环境字符串和同样的打开文件（在shell解释器进程中，执行一个命令就会创建一个子进程）在windows中该系统调用是：CreateProcess，CreateProcess既处理进程的创建，也负责把正确的程序装入新进程。关于创建的子进程，UNIX和windows：相同的是：进程创建后，父进程和子进程有各自不同的地址空间（多道技术要求物理层面实现进程之间内存的隔离），任何一个进程的在其地址空间中的修改都不会影响到另外一个进程。不同的是：在UNIX中，子进程的初始地址空间是父进程的一个副本，提示：子进程和父进程是可以有只读的共享内存区的。但是对于windows系统来说，从一开始父进程与子进程的地址空间就是不同的。进程的终止正常退出（自愿，如用户点击页面的叉号，或程序执行完毕调用发起系统调用正常退出，在Linux系统中用 exit,在Windows中用ExitProcess）出错退出（自愿）严重错误（非自愿，执行非法指令，如引用不存在的内存，I/O等，可以捕获异常，try…except）被其他进程杀死（非自愿，如 kill -9）进程的层次结构无论UNIX还是windows，进程只有一个父进程，不同的是：在UNIX中所有的进程，都是以init进程为根，组成树形结构。父子进程共同组成一个进程组，这样，当从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员。在windows中，没有进程层次的概念，所有的进程都是地位相同的，唯一类似于进程层次的暗示，是在创建进程时，父进程得到一个特别的令牌（称为句柄）,该句柄可以用来控制子进程，但是父进程有权把该句柄传给其他子进程，这样就没有层次了。进程的状态tail -f access.log |grep ‘404’执行程序tail，开启一个子进程，执行程序grep，开启另外一个子进程，两个进程之间基于管道’|’通讯，将tail的结果作为grep的输入。进程grep在等待输入（即I/O）时的状态称为阻塞，此时grep命令都无法运行其实在两种情况下会导致一个进程在逻辑上不能运行，进程挂起是自身原因，遇到I/O阻塞，便要让出CPU让其他进程去执行，这样保证CPU一直在工作与进程无关，是操作系统层面，可能会因为一个进程占用时间过多，或者优先级等原因，而调用其他的进程去使用CPU。因而一个进程由三种状态进程并发的实现进程并发的实现在于，硬件中断一个正在运行的进程，把此时进程运行的所有状态保存下来，为此，操作系统维护一张表格，即进程表（process table），每个进程占用一个进程表项（这些表项也称为进程控制块）该表存放了进程状态的重要信息：程序计数器、堆栈指针、内存分配状况、所有打开文件的状态、帐号和调度信息，以及其他在进程由运行态转为就绪态或阻塞态时，必须保存的信息，从而保证该进程在再次启动时，就像从未被中断过一样。开启进程的两种方式multiprocessing模块介绍python中的多线程无法利用多核优势，如果想要充分地使用多核CPU的资源（os.cpu_count()查看），在python中大部分情况需要使用多进程。Python提供了multiprocessing。multiprocessing模块用来开启子进程，并在子进程中执行我们定制的任务（比如函数），该模块与多线程模块threading的编程接口类似。multiprocessing模块的功能众多：支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。需要再次强调的一点是：与线程不同，进程没有任何共享状态，进程修改的数据，改动仅限于该进程内。Process类的介绍创建进程的类12345Process([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，可用来开启一个子进程强调：1. 需要使用关键字的方式来指定参数2. args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号参数介绍123456group参数未使用，值始终为Nonetarget表示调用对象，即子进程要执行的任务args表示调用对象的位置参数元组，args=(1,2,'mark',)kwargs表示调用对象的字典,kwargs=&#123;'name':'mark','age':18&#125;name为子进程的名称方法介绍1234567p.start()：启动进程，并调用该子进程中的p.run() p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法 p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁p.is_alive():如果p仍然运行，返回Truep.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间。属性介绍12345p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置p.name:进程的名称p.pid：进程的pidProcess类的使用:创建并开启子进程注意：在windows中Process()必须放到# if name == ‘main‘:下创建并开启子进程的方式一：直接使用Process12345678910111213141516171819202122import timeimport randomfrom multiprocessing import Processdef piao(name): print('%s piaoing' %name) time.sleep(random.randrange(1,5)) print('%s piao end' %name)if __name__ == '__main__': #实例化得到四个对象 p1=Process(target=piao,args=('mark',)) #必须加,号 p2=Process(target=piao,args=('jack',)) p3=Process(target=piao,args=('wang',)) p4=Process(target=piao,args=('liu',)) #调用对象下的方法，开启四个进程 p1.start() p2.start() p3.start() p4.start() print('主')创建并开启子进程的方式二：自定义类继承Process123456789101112131415161718192021222324252627import timeimport randomfrom multiprocessing import Processclass Piao(Process): def __init__(self,name): super().__init__() self.name=name def run(self): print('%s piaoing' %self.name) time.sleep(random.randrange(1,5)) print('%s piao end' %self.name)if __name__ == '__main__': #实例化得到四个对象 p1=Piao('mark') p2=Piao('jack') p3=Piao('wang') p4=Piao('liu') #调用对象下的方法，开启四个进程 p1.start() #start会自动调用run p2.start() p3.start() p4.start() print('主')进程之间的内存空间是隔离的123456789101112from multiprocessing import Processn=100 #在windows系统中应该把全局变量定义在if __name__ == '__main__'之上就可以了def work(): global n n=0 print('子进程内: ',n)if __name__ == '__main__': p=Process(target=work) p.start() print('主进程内: ',n)Process对象的join方法在主进程运行过程中如果想并发地执行其他的任务，我们可以开启子进程，此时主进程的任务与子进程的任务分两种情况情况一：在主进程的任务与子进程的任务彼此独立的情况下，主进程的任务先执行完毕后，主进程还需要等待子进程执行完毕，然后统一回收资源。情况二：如果主进程的任务在执行到某一个阶段时，需要等待子进程执行完毕后才能继续执行，就需要有一种机制能够让主进程检测子进程是否运行完毕，在子进程执行完毕后才继续执行，否则一直在原地阻塞，这就是join方法的作用12345678910111213141516from multiprocessing import Processimport timeimport randomimport osdef task(): print('%s is piaoing' %os.getpid()) time.sleep(random.randrange(1,3)) print('%s is piao end' %os.getpid())if __name__ == '__main__': p=Process(target=task) p.start() p.join() #等待p停止,才执行下一行代码 print('主')有了join，程序不就是串行了吗？？？1234567891011121314151617181920212223242526272829from multiprocessing import Processimport timeimport randomdef task(name): print('%s is piaoing' %name) time.sleep(random.randint(1,3)) print('%s is piao end' %name)if __name__ == '__main__': p1=Process(target=task,args=('mark',)) p2=Process(target=task,args=('jack',)) p3=Process(target=task,args=('wang',)) p4=Process(target=task,args=('liu',)) p1.start() p2.start() p3.start() p4.start() # 疑问: 既然join是等待进程结束, 那么我像下面这样写, 进程不就又变成串行的了吗? # 当然不是了, 必须明确：p.join()是让谁等？ # 很明显p.join()是让主线程等待p的结束，卡住的是主进程而绝非子进程p， p1.join() p2.join() p3.join() p4.join() print('主')详细解析如下：进程只要start就会在开始运行了,所以p1-p4.start()时,系统中已经有四个并发的进程了,而我们p1.join()是在等p1结束,没错p1只要不结束主线程就会一直卡在原地,这也是问题的关键,join是让主线程等,而p1-p4仍然是并发执行的,p1.join的时候,其余p2,p3,p4仍然在运行,等#p1.join结束,可能p2,p3,p4早已经结束了,这样p2.join,p3.join.p4.join直接通过检测，无需等待,所以4个join花费的总时间仍然是耗费时间最长的那个进程运行的时间上述启动进程与join进程可以简写为1234567p_l=[p1,p2,p3,p4]for p in p_l: p.start()for p in p_l: p.join()Process对象的其他方法或属性进程对象的其他方法 terminate与is_alive123456789101112131415161718from multiprocessing import Processimport timeimport randomdef task(name): print('%s is piaoing' %name) time.sleep(random.randrange(1,5)) print('%s is piao end' %name)if __name__ == '__main__': p1=Process(target=task,args=('egon',)) p1.start() p1.terminate()#关闭进程,不会立即关闭,所以is_alive立刻查看的结果可能还是存活 print(p1.is_alive()) #结果为True print('主') print(p1.is_alive()) #结果为False进程对象的其他属性 name与pid1234567891011121314from multiprocessing import Processimport timeimport randomdef task(name): print('%s is piaoing' %name) time.sleep(random.randrange(1,5)) print('%s is piao end' %name)if __name__ == '__main__': p1=Process(target=task,args=('mark',),name='子进程1') #可以用关键参数来指定进程名 p1.start() print(p1.name,p1.pid,)守护进程主进程创建守护进程 其一：守护进程会在主进程代码执行结束后就终止 其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止1234567891011121314from multiprocessing import Processimport timeimport randomdef task(name): print('%s is piaoing' %name) time.sleep(random.randrange(1,3)) print('%s is piao end' %name)if __name__ == '__main__': p=Process(target=task,args=('mark',)) p.daemon=True #一定要在p.start()前设置,设置p为守护进程,禁止p创建子进程,并且父进程代码执行结束,p即终止运行 p.start() print('主') #只要终端打印出这一行内容，那么守护进程p也就跟着结束掉了互斥锁进程之间数据不共享,但是共享同一套文件系统,所以访问同一个文件,或同一个打印终端,是没有问题的,而共享带来的是竞争，竞争带来的结果就是错乱，如下123456789101112#并发运行,效率高,但竞争同一打印终端,带来了打印错乱from multiprocessing import Processimport os,timedef work(): print('%s is running' %os.getpid()) time.sleep(2) print('%s is done' %os.getpid())if __name__ == '__main__': for i in range(3): p=Process(target=work) p.start()如何控制，就是加锁处理。而互斥锁的意思就是互相排斥，如果把多个进程比喻为多个人，互斥锁的工作原理就是多个人都要去争抢同一个资源：卫生间，一个人抢到卫生间后上一把锁，其他人都要等着，等到这个完成任务后释放锁，其他人才有可能有一个抢到……所以互斥锁的原理，就是把并发改成穿行，降低了效率，但保证了数据安全不错乱1234567891011121314#由并发变成了串行,牺牲了运行效率,但避免了竞争from multiprocessing import Process,Lockimport os,timedef work(lock): lock.acquire() #加锁 print('%s is running' %os.getpid()) time.sleep(2) print('%s is done' %os.getpid()) lock.release() #释放锁if __name__ == '__main__': lock=Lock() for i in range(3): p=Process(target=work,args=(lock,)) p.start()模拟抢票123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#文件db.txt的内容为：&#123;"count":1&#125;#注意一定要用双引号，不然json无法识别from multiprocessing import Processimport time,jsondef search(name): dic=json.load(open('db.txt')) time.sleep(1) print('\033[43m%s 查到剩余票数%s\033[0m' %(name,dic['count']))def get(name): dic=json.load(open('db.txt')) time.sleep(1) #模拟读数据的网络延迟 if dic['count'] &gt;0: dic['count']-=1 time.sleep(1) #模拟写数据的网络延迟 json.dump(dic,open('db.txt','w')) print('\033[46m%s 购票成功\033[0m' %name)def task(name): search(name) get(name)if __name__ == '__main__': for i in range(10): #模拟并发10个客户端抢票 name='&lt;路人%s&gt;' %i p=Process(target=task,args=(name,)) p.start()'''&lt;路人0&gt; 查到剩余票数1&lt;路人1&gt; 查到剩余票数1&lt;路人2&gt; 查到剩余票数1&lt;路人3&gt; 查到剩余票数1&lt;路人4&gt; 查到剩余票数1&lt;路人5&gt; 查到剩余票数1&lt;路人6&gt; 查到剩余票数1&lt;路人7&gt; 查到剩余票数1&lt;路人8&gt; 查到剩余票数1&lt;路人9&gt; 查到剩余票数1&lt;路人0&gt; 购票成功&lt;路人4&gt; 购票成功&lt;路人1&gt; 购票成功&lt;路人5&gt; 购票成功&lt;路人3&gt; 购票成功&lt;路人7&gt; 购票成功&lt;路人2&gt; 购票成功&lt;路人6&gt; 购票成功&lt;路人8&gt; 购票成功&lt;路人9&gt; 购票成功'''并发运行，效率高，但竞争写同一文件，数据写入错乱,只有一张票，卖成功给了10个人加锁处理：购票行为由并发变成了串行，牺牲了运行效率，但保证了数据安全12345678910111213141516171819202122232425262728293031323334353637383940414243#把文件db.txt的内容重置为：&#123;"count":1&#125;from multiprocessing import Process,Lockimport time,jsondef search(name): dic=json.load(open('db.txt')) time.sleep(1) print('\033[43m%s 查到剩余票数%s\033[0m' %(name,dic['count']))def get(name): dic=json.load(open('db.txt')) time.sleep(1) #模拟读数据的网络延迟 if dic['count'] &gt;0: dic['count']-=1 time.sleep(1) #模拟写数据的网络延迟 json.dump(dic,open('db.txt','w')) print('\033[46m%s 购票成功\033[0m' %name)def task(name,lock): search(name) with lock: #相当于lock.acquire(),执行完自代码块自动执行lock.release() get(name)if __name__ == '__main__': lock=Lock() for i in range(10): #模拟并发10个客户端抢票 name='&lt;路人%s&gt;' %i p=Process(target=task,args=(name,lock)) p.start()'''&lt;路人0&gt; 查到剩余票数1&lt;路人1&gt; 查到剩余票数1&lt;路人2&gt; 查到剩余票数1&lt;路人3&gt; 查到剩余票数1&lt;路人4&gt; 查到剩余票数1&lt;路人5&gt; 查到剩余票数1&lt;路人6&gt; 查到剩余票数1&lt;路人7&gt; 查到剩余票数1&lt;路人8&gt; 查到剩余票数1&lt;路人9&gt; 查到剩余票数1&lt;路人0&gt; 购票成功'''互斥锁与join使用join可以将并发变成串行，互斥锁的原理也是将并发变成穿行，那我们直接使用join就可以了啊，为何还要互斥锁？1234567891011121314151617181920212223242526272829303132333435363738394041#把文件db.txt的内容重置为：&#123;"count":1&#125;from multiprocessing import Process,Lockimport time,jsondef search(name): dic=json.load(open('db.txt')) print('\033[43m%s 查到剩余票数%s\033[0m' %(name,dic['count']))def get(name): dic=json.load(open('db.txt')) time.sleep(1) #模拟读数据的网络延迟 if dic['count'] &gt;0: dic['count']-=1 time.sleep(1) #模拟写数据的网络延迟 json.dump(dic,open('db.txt','w')) print('\033[46m%s 购票成功\033[0m' %name)def task(name,): search(name) get(name)if __name__ == '__main__': for i in range(10): name='&lt;路人%s&gt;' %i p=Process(target=task,args=(name,)) p.start() p.join() '''&lt;路人0&gt; 查到剩余票数1&lt;路人0&gt; 购票成功&lt;路人1&gt; 查到剩余票数0&lt;路人2&gt; 查到剩余票数0&lt;路人3&gt; 查到剩余票数0&lt;路人4&gt; 查到剩余票数0&lt;路人5&gt; 查到剩余票数0&lt;路人6&gt; 查到剩余票数0&lt;路人7&gt; 查到剩余票数0&lt;路人8&gt; 查到剩余票数0&lt;路人9&gt; 查到剩余票数0'''发现使用join将并发改成穿行，确实能保证数据安全，但问题是连查票操作也变成只能一个一个人去查了，很明显大家查票时应该是并发地去查询而无需考虑数据准确与否，此时join与互斥锁的区别就显而易见了，join是将一个任务整体串行，而互斥锁的好处则是可以将一个任务中的某一段代码串行，比如只让task函数中的get任务串行123456def task(name,): search(name) # 并发执行 lock.acquire() get(name) #串行执行 lock.release()互斥锁小结加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行地修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。虽然可以用文件共享数据实现进程间通信，但问题是：效率低（共享数据基于文件，而文件是硬盘上的数据）需要自己加锁处理因此我们最好找寻一种解决方案能够兼顾：效率高（多个进程共享一块内存的数据）帮我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。队列和管道都是将数据存放于内存中，而队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，因而队列才是进程间通信的最佳选择。我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。队列进程彼此之间互相隔离，要实现进程间通信（IPC），multiprocessing模块支持两种形式：队列和管道，这两种方式都是使用消息传递的创建队列的类–底层就是以管道和锁定的方式实现1Queue([maxsize]):创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。参数介绍1234maxsize是队列中允许最大项数，省略则无大小限制。但需要明确： 1、队列内存放的是消息而非大数据 2、队列占用的是内存空间，因而maxsize即便是无大小限制也受限于内存大小主要方法介绍12q.put方法用以插入数据到队列中。q.get方法可以从队列读取并且删除一个元素。其他方法q.cancel_join_thread():不会在进程退出时自动连接后台线程。可以防止join_thread()方法阻塞q.close():关闭队列，防止队列中加入更多数据。调用此方法，后台线程将继续写入那些已经入队列但尚未写入的数据，但将在此方法完成时马上关闭。如果q被垃圾收集，将调用此方法。关闭队列不会在队列使用者中产生任何类型的数据结束信号或异常。例如，如果某个使用者正在被阻塞在get()操作上，关闭生产者中的队列不会导致get()方法返回错误。q.join_thread()：连接队列的后台线程。此方法用于在调用q.close()方法之后，等待所有队列项被消耗。默认情况下，此方法由不是q的原始创建者的所有进程调用。调用q.cancel_join_thread方法可以禁止这种行为队列的使用12345678910111213141516from multiprocessing import Process,Queueq=Queue(3)#put ,get ,put_nowait,get_nowait,full,emptyq.put(1)q.put(2)q.put(3)print(q.full()) #满了# q.put(4) #再放就阻塞住了print(q.get())print(q.get())print(q.get())print(q.empty()) #空了# print(q.get()) #再取就阻塞住了生产者消费者模型生产者消费者模型介绍生产者消费者模型实现生产者消费者模型总结]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程之多线程]]></title>
    <url>%2Fposts%2Ffeec4dc1%2F</url>
    <content type="text"><![CDATA[Python目录并发编程之多进程并发编程之多线程并发编程之协程并发编程之IO模型僵尸进程与孤儿进程本章简介复制表复制表结构＋记录#]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程之IO模型]]></title>
    <url>%2Fposts%2Fd7930d0c%2F</url>
    <content type="text"><![CDATA[Python目录并发编程之多进程并发编程之多线程并发编程之协程并发编程之IO模型本章简介复制表复制表结构＋记录#]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[僵尸进程与孤儿进程]]></title>
    <url>%2Fposts%2Fa4cae15b%2F</url>
    <content type="text"><![CDATA[Python目录并发编程之多进程并发编程之多线程并发编程之协程并发编程之IO模型僵尸进程与孤儿进程本章简介11操作系统简介]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程之协程]]></title>
    <url>%2Fposts%2F65bf44ba%2F</url>
    <content type="text"><![CDATA[Python目录并发编程之多进程并发编程之多线程并发编程之协程并发编程之IO模型僵尸进程与孤儿进程本章简介复制表复制表结构＋记录#]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python目录]]></title>
    <url>%2Fposts%2F769e859c%2F</url>
    <content type="text"><![CDATA[基础语法Python基础Python字符编码Python基本数据类型文件操作文件操作函数相关函数生成器与迭代器常用模块模块、包、软件开发目录规范time&amp;datatime 模块random 模块os 模块sys 模块shutil 模块json 和 pickle 模块shelve 模块xml 模块configparser 模块hashlib 模块subprocess 模块logging 模块re 模块面向对象面向对象网络编程网络编程并发编程并发编程之多进程并发编程之多线程并发编程之协程并发编程之IO模型僵尸进程与孤儿进程Python2Python2]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表操作-表的增删改查]]></title>
    <url>%2Fposts%2F7c844f8e%2F</url>
    <content type="text"><![CDATA[MySQL目录表操作-存储引擎介绍表操作-表的增删改查表操作-数据类型表操作-完整性约束本章简介创建表查看表结构修改表结构复制表复制表结构＋记录只复制表结构删除表表相当于文件，表中的一条记录就相当于文件的一行内容，不同的是，表中的一条记录有对应的标题，称为表的字段。创建表语法12345create table 表名( 字段名1 类型[(宽度) 约束条件], 字段名2 类型[(宽度) 约束条件], 字段名3 类型[(宽度) 约束条件]);注意在同一张表中，字段名是不能相同宽度和约束条件可选字段名和类型是必须的实例123456789101112131415161718192021mysql&gt; create table t1(id int, name varchar(50),sex enum('male','female'),age int(3));Query OK, 0 rows affected (0.02 sec)mysql&gt; show tables;+--------------------+| Tables_in_dbtest01 |+--------------------+| t1 |+--------------------+1 row in set (0.00 sec)mysql&gt; desc t1;+-------+-----------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-----------------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(50) | YES | | NULL | || sex | enum('male','female') | YES | | NULL | || age | int(3) | YES | | NULL | |+-------+-----------------------+------+-----+---------+-------+4 rows in set (0.01 sec)往表中插入数据123456789101112mysql&gt; insert into t1 values (1,'mark','male',18),(2,'jack','female',28);Query OK, 2 rows affected (0.00 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; select * from t1;+------+------+--------+------+| id | name | sex | age |+------+------+--------+------+| 1 | mark | male | 18 || 2 | jack | female | 28 |+------+------+--------+------+2 rows in set (0.00 sec)id，name，sex，age 称为字段，其余的，一行内容称为一条记录。查看表结构describe t1; #查看表结构，可简写为desc 表名123456789101112mysql&gt; desc t1;+-------+-----------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-----------------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(50) | YES | | NULL | || sex | enum('male','female') | YES | | NULL | || age | int(3) | YES | | NULL | |+-------+-----------------------+------+-----+---------+-------+4 rows in set (0.00 sec)mysql&gt;修改表结构语法修改表名ALTER TABLE 表名 RENAME 新表名;增加字段ALTER TABLE 表名 ADD 字段名 数据类型 [完整性约束条件…], ADD 字段名 数据类型 [完整性约束条件…];ALTER TABLE 表名 ADD 字段名 数据类型 [完整性约束条件…] FIRST; # 添加到最前面ALTER TABLE 表名 ADD 字段名 数据类型 [完整性约束条件…] AFTER 字段名; # 添加到某个字段之后删除字段ALTER TABLE 表名 DROP 字段名;修改字段ALTER TABLE 表名 MODIFY 字段名 数据类型 [完整性约束条件…];ALTER TABLE 表名 CHANGE 旧字段名 新字段名 旧数据类型 [完整性约束条件…];ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型 [完整性约束条件…];实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 将表名 t1 修改为 t2mysql&gt; alter table t1 rename t2; # 修改 t2 存储引擎为 innodbmysql&gt; alter table t2 engine=innodb;mysql&gt; show create table t2\G# 为 t2 添加字段 class 、heightmysql&gt; alter table t2 add class varchar(20) not null,add height int(3) not null default 180;mysql&gt; alter table t2 add numble varchar(10) not null after name; # 添加name字段之后mysql&gt; alter table t2 add school enum('shanghai','beijing') default 'shanghai' first; # 添加到最前面# 删除字段mysql&gt; alter table t2 drop sex;# 修改字段类型modifymysql&gt; alter table t2 modify age int(4);# 设为主键modifymysql&gt; alter table t2 modify id int(11) not null primary key auto_increment; # 针对已有的主键增加auto_increment(增加约束条件)mysql&gt; alter table t2 modify id int(11) not null auto_increment;# 对已经存在的表增加复合主键mysql&gt; desc t3;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(50) | YES | | NULL | || score | varchar(10) | NO | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec)mysql&gt; alter table t3 add primary key(id,name);Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc t3;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(50) | NO | PRI | NULL | || score | varchar(10) | NO | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec)# 删除主键：首先删除自增约束，然后再删除主键mysql&gt; alter table t2 modify id int(11) not null;mysql&gt; alter table t2 drop primary key;复制表复制表结构＋记录key不会复制: 主键、外键和索引1mysql&gt; create table t4 select * from t2;只复制表结构12345# 方法一mysql&gt; create table t5 select * from t2 where 1=2; #条件为假，查不到任何记录# 方式二mysql&gt; create table t6 like t2;删除表1DROP TABLE 表名;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表操作-数据类型]]></title>
    <url>%2Fposts%2F51552693%2F</url>
    <content type="text"><![CDATA[MySQL目录表操作-存储引擎介绍表操作-表的增删改查 表操作-数据类型表操作-完整性约束本章简介概述数值类型整数类型浮点型位类型日期类型字符串类型枚举类型与集合类型MySQL中定义数据字段的类型对你数据库的优化是非常重要的。概述存储引擎决定了表的类型，而表内存放的数据也要有不同的类型，每种数据类型都有自己的宽度，但宽度是可选的mysql常用数据类型:数字类型字符串类型时间类型枚举类型与集合类型数值类型MySQL支持所有标准SQL数值数据类型。整型：tinyint(MySQL中无布尔值，使用tinyint(1)构造。)smallintmediumintintbigint小数：float ：在位数比较短的情况下不精准double ：在位数比较长的情况下不精准(0.000001230123123123 存成：0.000001230000)decimal：（如果用小数，则用推荐使用decimal;好处：精准，内部原理是以字符串形式去存）整数类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# tinyint默认是有符号,范围是（-128,127）mysql&gt; create table t6(x tinyint);Query OK, 0 rows affected (0.02 sec)mysql&gt; desc t6;+-------+------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+------------+------+-----+---------+-------+| x | tinyint(4) | YES | | NULL | |+-------+------------+------+-----+---------+-------+1 row in set (0.01 sec)mysql&gt; insert into t6 values (-127),(127);Query OK, 2 rows affected (0.00 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; insert into t6 values (-127),(129); # mysql 5.7显示报错，也有版本会将其存为边界值(127)ERROR 1264 (22003): Out of range value for column 'x' at row 2# 设置无符号 tinyint,范围是(0，255)mysql&gt; create table t7(x tinyint unsigned);Query OK, 0 rows affected (0.02 sec)mysql&gt; insert into t7 values(-1),(0),(255);ERROR 1264 (22003): Out of range value for column 'x' at row 1mysql&gt; insert into t7 values(0),(255);Query OK, 2 rows affected (0.00 sec)Records: 2 Duplicates: 0 Warnings: 0# int 默认是有符号 (-2 147 483 648，2 147 483 647)mysql&gt; create table t8(x int);Query OK, 0 rows affected (0.02 sec)mysql&gt; insert into t8 values(-20000),(302300);Query OK, 2 rows affected (0.00 sec)Records: 2 Duplicates: 0 Warnings: 0# 设置无符号int，范围(0，4 294 967 295)mysql&gt; create table t10(x int unsigned);Query OK, 0 rows affected (0.01 sec)mysql&gt; insert into t10 values(-100),(200);ERROR 1264 (22003): Out of range value for column 'x' at row 1mysql&gt; insert into t10 values(200);Query OK, 1 row affected (0.01 sec)mysql&gt; desc t10;+-------+------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| x | int(10) unsigned | YES | | NULL | |+-------+------------------+------+-----+---------+-------+1 row in set (0.00 sec)# 用zerofill测试整数类型的显示宽度mysql&gt; create table t11(x int(3) zerofill);Query OK, 0 rows affected (0.01 sec)mysql&gt; insert into t11 values(1),(1111);Query OK, 2 rows affected (0.01 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; select * from t11;+------+| x |+------+| 001 || 1111 | # 超过宽度限制仍然可以保存+------+2 rows in set (0.00 sec)注意：为该类型指定宽度时，仅仅只是指定查询结果的显示宽度，与存储范围无关，存储范围如下其实我们完全没必要为整数类型指定显示宽度，使用默认的就可以了默认的显示宽度，都是在最大值的基础上加1int的存储宽度是4个Bytes，即32个bit，即2**32无符号最大值为：4294967296-1;有符号最大值：2147483648-1有符号和无符号的最大数字需要的显示宽度均为10，而针对有符号的最小值则需要11位才能显示完全，所以int类型默认的显示宽度为11是非常合理的最后：整形类型，其实没有必要指定显示宽度，使用默认的就ok浮点型定点数类型 DEC等同于DECIMAL 浮点类型：FLOAT DOUBLE123456789101112131415161718192021222324### FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]单精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。m最大值为255，d最大值为30 1.精确度：随着小数的增多，精度变得不准确 2.有符号：(-3.402823466E+38 ,-1.175494351E-38) (1.175494351E-38 ,3.402823466E+38) 3.无符号：(1.175494351E-38,3.402823466E+38)### DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]双精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。m最大值为255，d最大值为30 1.随着小数的增多，精度比float要高，但也会变得不准确### decimal[(m[,d])] [unsigned] [zerofill]准确的小数值，m是数字总个数（负号不算），d是小数点后个数。 m最大值为65，d最大值为30。 1.随着小数的增多，精度始终准确 2.对于精确数值计算时需要用此类型 3.decaimal能够存储精确值的原因在于其内部按照字符串存储 ### 实例 mysql&gt; create table f1(x float(256,31));ERROR 1425 (42000): Too big scale 31 specified for column 'x'. Maximum is 30.mysql&gt; create table f1(x float(255,30));Query OK, 0 rows affected (0.02 sec)位类型(了解)BIT(M)可以用来存放多位二进制数，M范围从1~64，如果不写默认为1位。注意：对于位字段需要使用函数读取bin()显示为二进制hex()显示为十六进制12345678910111213141516171819202122232425262728293031MariaDB [db1]&gt; create table t9(id bit);MariaDB [db1]&gt; desc t9; #bit默认宽度为1+-------+--------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+--------+------+-----+---------+-------+| id | bit(1) | YES | | NULL | |+-------+--------+------+-----+---------+-------+MariaDB [db1]&gt; insert into t9 values(8);MariaDB [db1]&gt; select * from t9; #直接查看是无法显示二进制位的+------+| id |+------+| |+------+MariaDB [db1]&gt; select bin(id),hex(id) from t9; #需要转换才能看到+---------+---------+| bin(id) | hex(id) |+---------+---------+| 1 | 1 |+---------+---------+MariaDB [db1]&gt; alter table t9 modify id bit(5);MariaDB [db1]&gt; insert into t9 values(8);MariaDB [db1]&gt; select bin(id),hex(id) from t9;+---------+---------+| bin(id) | hex(id) |+---------+---------+| 1 | 1 || 1000 | 8 |+---------+---------+日期类型每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值TIMESTAMP类型有专有的自动更新特性最常用：datetime1234567891011121314151617181920212223242526272829303132333435create table student( id int, name char(6), born_year year, birth_date date, class_time time, reg_time datetime);insert into student values(1,'mark',now(),now(),now(),now());insert into student values(2,'jack',"1997","1997-12-12","12:12:12","2016-12-12 12:12:12");mysql&gt; desc student;+------------+----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+------------+----------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | char(6) | YES | | NULL | || born_year | year(4) | YES | | NULL | || birth_date | date | YES | | NULL | || class_time | time | YES | | NULL | || reg_time | datetime | YES | | NULL | |+------------+----------+------+-----+---------+-------+6 rows in set (0.00 sec)mysql&gt; select * from student;+------+------+-----------+------------+------------+---------------------+| id | name | born_year | birth_date | class_time | reg_time |+------+------+-----------+------------+------------+---------------------+| 1 | mark | 2017 | 2017-05-03 | 10:59:05 | 2017-05-03 10:59:05 || 2 | jack | 1997 | 1997-12-12 | 12:12:12 | 2016-12-12 12:12:12 |+------+------+-----------+------------+------------+---------------------+当在命令行输错了语句时，可以使用 \c 终止运行，记得灵活使用。datetime与timestamp的区别在实际应用的很多场景中，MySQL的这两种日期类型都能够满足我们的需要，存储精度都为秒，但在某些情况下，会展现出他们各自的优劣。下面就来总结一下两种日期类型的区别。DATETIME的日期范围是1001——9999年，TIMESTAMP的时间范围是1970——2038年。DATETIME存储时间与时区无关，TIMESTAMP存储时间与时区有关，显示的值也依赖于时区。在mysql服务器，操作系统以及客户端连接都有时区的设置。DATETIME使用8字节的存储空间，TIMESTAMP的存储空间为4字节。因此，TIMESTAMP比DATETIME的空间利用率更高。DATETIME的默认值为null；TIMESTAMP的字段默认不为空（not null）,默认值为当前时间（CURRENT_TIMESTAMP），如果不做特殊处理，并且update语句中没有指定该列的更新值，则默认更新为当前时间。字符串类型char和varchar括号内的参数指的都是字符的长度char类型：定长，简单粗暴，浪费空间，存取速度快字符长度范围：0-255（一个中文是一个字符，是utf8编码的3个字节）存储：存储char类型的值时，会往右填充空格来满足长度例如：指定长度为10，存&gt;10个字符则报错，存&lt;10个字符则用空格填充直到凑够10个字符存储检索：在检索或者说查询时，查出的结果会自动删除尾部的空格，除非我们打开pad_char_to_full_length SQL模式（SET sql_mode = ‘PAD_CHAR_TO_FULL_LENGTH’;）varchar类型：变长，精准，节省空间，存取速度慢字符长度范围：0-65535（如果大于21845会提示用其他类型 。mysql行最大限制为65535字节，字符编码为utf-8：https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html）存储：varchar类型存储数据的真实内容，不会用空格填充，如果’ab ‘,尾部的空格也会被存起来强调：varchar类型会在真实数据前加1-2Bytes的前缀，该前缀用来表示真实数据的bytes字节数（1-2Bytes最大表示65535个数字，正好符合mysql对row的最大字节限制，即已经足够使用）如果真实的数据&lt;255bytes则需要1Bytes的前缀（1Bytes=8bit 2**8最大表示的数字为255）如果真实的数据&gt;255bytes则需要2Bytes的前缀（2Bytes=16bit 2**16最大表示的数字为65535）检索：尾部有空格会保存下来，在检索或者说查询时，也会正常显示包含空格在内的内容char填充空格来满足固定长度，但是在查询时却会删除尾部的空格（装作自己好像没有浪费过空间一样），然后修改sql_mode让其现出原形123456789101112131415161718192021222324252627282930313233343536373839404142mysql&gt; create table t1(x char(5),y varchar(5));Query OK, 0 rows affected (0.26 sec)# char存5个字符，而varchar存4个字符mysql&gt; insert into t1 values('你瞅啥 ','你瞅啥 ');Query OK, 1 row affected (0.05 sec)mysql&gt; SET sql_mode='';Query OK, 0 rows affected, 1 warning (0.00 sec)# 在检索时char将自己浪费的2个字符给删掉了，装的好像自己没浪费过空间一样，而varchar很老实，存了多少，就显示多少mysql&gt; select x,char_length(x),y,char_length(y) from t1; +-----------+----------------+------------+----------------+| x | char_length(x) | y | char_length(y) |+-----------+----------------+------------+----------------+| 你瞅啥 | 3 | 你瞅啥 | 4 |+-----------+----------------+------------+----------------+row in set (0.00 sec)# 让char现出原形mysql&gt; SET sql_mode = 'PAD_CHAR_TO_FULL_LENGTH';Query OK, 0 rows affected (0.00 sec)# char原形毕露了......mysql&gt; select x,char_length(x),y,char_length(y) from t1;+-------------+----------------+------------+----------------+| x | char_length(x) | y | char_length(y) |+-------------+----------------+------------+----------------+| 你瞅啥 | 5 | 你瞅啥 | 4 |+-------------+----------------+------------+----------------+row in set (0.00 sec)# char类型：3个中文字符+2个空格=11Bytes# varchar类型:3个中文字符+1个空格=10Bytesmysql&gt; select x,length(x),y,length(y) from t1;+-------------+-----------+------------+-----------+| x | length(x) | y | length(y) |+-------------+-----------+------------+-----------+| 你瞅啥 | 11 | 你瞅啥 | 10 |+-------------+-----------+------------+-----------+row in set (0.00 sec)length：查看字节数char_length:查看字符数虽然 CHAR 和 VARCHAR 的存储方式不太相同,但是对于两个字符串的比较,都只比 较其值,忽略 CHAR 值存在的右填充,即使将 SQL_MODE 设置为 PAD_CHAR_TO_FULL_ LENGTH 也一样,但这不适用于like123456789101112131415161718192021mysql&gt; create table names (myname char(10));Query OK, 0 rows affected (0.02 sec)mysql&gt; insert into names values('mark');Query OK, 1 row affected (0.00 sec)mysql&gt; select myname = 'mark',myname = 'mark ' from names;+-----------------+-------------------+| myname = 'mark' | myname = 'mark ' |+-----------------+-------------------+| 1 | 1 |+-----------------+-------------------+1 row in set (0.00 sec)mysql&gt; select myname like 'mark',myname like 'mark ' from names;+--------------------+----------------------+| myname like 'mark' | myname like 'mark ' |+--------------------+----------------------+| 0 | 0 |+--------------------+----------------------+1 row in set (0.00 sec)总结常用字符串系列：char与varchar注：虽然varchar使用起来较为灵活，但是从整个系统的性能角度来说，char数据类型的处理速度更快，有时甚至可以超出varchar处理速度的50%。因此，用户在设计数据库时应当综合考虑各方面的因素，以求达到最佳的平衡其他字符串系列（效率：char&gt;varchar&gt;text）TEXT系列 TINYTEXT TEXT MEDIUMTEXT LONGTEXTBLOB 系列 TINYBLOB BLOB MEDIUMBLOB LONGBLOBBINARY系列 BINARY VARBINARYtext：text数据类型用于保存变长的大字符串，可以组多到65535 (2**16 − 1)个字符.mediumtext：A TEXT column with a maximum length of 16,777,215 (2**24 − 1) characters.longtext：A TEXT column with a maximum length of 4,294,967,295 or 4GB (2**32 − 1) characters.枚举类型与集合类型字段的值只能在给定范围中选择，如单选框，多选框enum 单选 只能在给定的范围内选一个值，如性别 sex 男male/女femaleset 多选 在给定的范围内可以选择一个或一个以上的值（爱好1,爱好2,爱好3…）12345678910111213141516171819202122232425262728293031323334353637mysql&gt; create table consumer( -&gt; id int, -&gt; name char(16), -&gt; sex enum('male','female','other'), -&gt; level enum('vip1','vip2','vip3'), -&gt; hobbies set('play','music','read','run') -&gt; );Query OK, 0 rows affected (0.03 sec)mysql&gt; insert into consumer values -&gt; (1,'mark','male','vip2','music,read');Query OK, 1 row affected (0.00 sec)mysql&gt; insert into consumer values -&gt; (1,'jack','xxxxx','vip2','music,read');Query OK, 1 row affected, 1 warning (0.00 sec)mysql&gt; select * from consumer;+------+------------------+------+-------+------------+| id | name | sex | level | hobbies |+------+------------------+------+-------+------------+| 1 | mark | male | vip2 | music,read || 1 | jack | | vip2 | music,read |+------+------------------+------+-------+------------+2 rows in set (0.00 sec)mysql&gt; desc consumer;+---------+----------------------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------+----------------------------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | char(16) | YES | | NULL | || sex | enum('male','female','other') | YES | | NULL | || level | enum('vip1','vip2','vip3') | YES | | NULL | || hobbies | set('play','music','read','run') | YES | | NULL | |+---------+----------------------------------+------+-----+---------+-------+5 rows in set (0.00 sec)参考：http://www.runoob.com/mysql/mysql-data-types.html]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表操作-存储引擎介绍]]></title>
    <url>%2Fposts%2F2ddc81ce%2F</url>
    <content type="text"><![CDATA[MySQL目录表操作-存储引擎介绍表操作-表的增删改查表操作-数据类型表操作-完整性约束本章简介什么是存储引擎mysql支持的存储引擎使用存储引擎查看某张表的存储引擎什么是存储引擎存储引擎就是表的类型现实生活中我们用来存储数据的文件有不同的类型，每种文件类型对应各自不同的处理机制：比如处理文本用txt类型，处理表格用excel，处理图片用png等。数据库中的表也应该有不同的类型，表的类型不同，会对应mysql不同的存取机制，表类型又称为存储引擎。存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型（即存储和操作此表的类型）在Oracle 和SQL Server等数据库中只有一种存储引擎，所有数据存储管理机制都是一样的。而MySql数据库提供了多种存储引擎。用户可以根据不同的需求为数据表选择不同的存储引擎，用户也可以根据自己的需要编写自己的存储引擎。SQL 解析器、SQL 优化器、缓冲池、存储引擎等组件在每个数据库中都存在,但不是每 个数据库都有这么多存储引擎。MySQL 的插件式存储引擎可以让存储引擎层的开发人员设 计他们希望的存储层,例如,有的应用需要满足事务的要求,有的应用则不需要对事务有这 么强的要求 ;有的希望数据能持久存储,有的只希望放在内存中,临时并快速地提供对数据 的查询。mysql支持的存储引擎12345678910111213141516mysql&gt; show engines\G #查看所有支持的存储引擎mysql&gt; show engines;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine | Support | Comment | Transactions | XA | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES || MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO || MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO || BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO || MyISAM | YES | MyISAM storage engine | NO | NO | NO || CSV | YES | CSV storage engine | NO | NO | NO || ARCHIVE | YES | Archive storage engine | NO | NO | NO || PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO || FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+9 rows in set (0.00 sec)也可以编写专属于自己的引擎。开源的魅力所在。使用存储引擎方式一：建表时指定123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051mysql&gt; CREATE DATABASE dbtest01 charset utf8; Query OK, 1 row affected (0.00 sec)mysql&gt; use dbtest01;Database changedmysql&gt; create table t1(id int)engine=innodb;Query OK, 0 rows affected (0.02 sec)mysql&gt; create table t2(id int)engine=memory;Query OK, 0 rows affected (0.01 sec)mysql&gt; create table t3(id int)engine=blackhole;Query OK, 0 rows affected (0.01 sec)mysql&gt; create table t4(id int)engine=myisam;Query OK, 0 rows affected (0.02 sec)mysql&gt; mysql&gt; insert into t1 values(1);Query OK, 1 row affected (0.01 sec)mysql&gt; insert into t2 values(1);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into t3 values(1);Query OK, 1 row affected (0.01 sec)mysql&gt; insert into t4 values(1);Query OK, 1 row affected (0.00 sec)mysql&gt; mysql&gt; show tables;+--------------------+| Tables_in_dbtest01 |+--------------------+| t1 || t2 || t3 || t4 |+--------------------+4 rows in set (0.00 sec)mysql&gt; select * from t1;+------+| id |+------+| 1 |+------+1 row in set (0.00 sec)mysql&gt;看一下创建表之后的文件，发现不同的存储引擎所产生的文件是有各不相同的，说明存取机制是不一样的12weizhendeMacBook-Pro:~ root# ls /usr/local/mysql/data/dbtest01db.opt t1.frm t1.ibd t2.frm t3.frm t4.MYD t4.MYI t4.frm方式二：在配置文件中指定默认的存储引擎1234/etc/my.cnf[mysqld]default-storage-engine=INNODBinnodb_file_per_table=1查看某张表的存储引擎12mysql&gt; show create table t2\G # 注意最后不要加分号，否则报错mysql&gt; show table status from dbtest01 where name='t2'\G # 查看表详细信息]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表操作-完整性约束]]></title>
    <url>%2Fposts%2F48a1b448%2F</url>
    <content type="text"><![CDATA[MySQL目录表操作-存储引擎介绍表操作-表的增删改查表操作-数据类型表操作-完整性约束本章简介not null与defaultunique设置唯一约束 UNIQUEnot null+unique联合唯一primary key单列主键多列主键auto_incrementforeign keyforeign key 案例找出两张表之间的关系建立表之间的关系约束条件与数据类型宽度一样，都是可选参数，主要用于保证数据的完整性和一致性123456789PRIMARY KEY (PK) 标识该字段为该表的主键，可以唯一的标识记录FOREIGN KEY (FK) 标识该字段为该表的外键NOT NULL 标识该字段不能为空UNIQUE KEY (UK) 标识该字段的值是唯一的AUTO_INCREMENT 标识该字段的值自动增长（整数类型，而且为主键）DEFAULT 为该字段设置默认值UNSIGNED 无符号ZEROFILL 使用0填充说明是否允许为空，默认NULL，可设置NOT NULL，字段不允许为空，必须赋值字段是否有默认值，缺省的默认值是NULL，如果插入记录时不给字段赋值，此字段使用默认值sex enum(‘male’,’female’) not null default ‘male’age int unsigned NOT NULL default 20 必须为正值（无符号） 不允许为空 默认是20是否是key主键 primary key外键 foreign key索引 (index,unique…)not null与default1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253==================not null====================mysql&gt; create table t1(id int); #id字段默认可以插入空mysql&gt; desc t1 ;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| id | int(11) | YES | | NULL | |+-------+---------+------+-----+---------+-------+mysql&gt; insert into t1 values(); #可以插入空mysql&gt; create table t2(id int not null); #设置字段id不为空mysql&gt; desc t2;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| id | int(11) | NO | | NULL | |+-------+---------+------+-----+---------+-------+mysql&gt; insert into t2 values(); #不能插入空ERROR 1364 (HY000): Field 'id' doesn't have a default value==================default====================#设置id字段有默认值后，则无论id字段是null还是not null，都可以插入空，插入空默认填入default指定的默认值mysql&gt; create table t3(id int default 1);mysql&gt; alter table t3 modify id int not null default 1;==================综合练习====================mysql&gt; create table student( -&gt; name varchar(20) not null, -&gt; age int(3) unsigned not null default 18, -&gt; sex enum('male','female') default 'male', -&gt; hobby set('play','study','read','music') default 'play,music' -&gt; );mysql&gt; desc student;+-------+------------------------------------+------+-----+------------+-------+| Field | Type | Null | Key | Default | Extra |+-------+------------------------------------+------+-----+------------+-------+| name | varchar(20) | NO | | NULL | || age | int(3) unsigned | NO | | 18 | || sex | enum('male','female') | YES | | male | || hobby | set('play','study','read','music') | YES | | play,music | |+-------+------------------------------------+------+-----+------------+-------+mysql&gt; insert into student(name) values('mark');mysql&gt; select * from student;+------+-----+------+------------+| name | age | sex | hobby |+------+-----+------+------------+| mark | 18 | male | play,music |+------+-----+------+------------+unique设置唯一约束 UNIQUE123456789101112131415161718192021222324============设置唯一约束 UNIQUE===============方法一：create table department1(id int,name varchar(20) unique,comment varchar(100));方法二：create table department2(id int,name varchar(20),comment varchar(100),constraint uk_name unique(name));注意：constraint uk_name 描述信息可以不用写create table department2( id int, name varchar(20), comment varchar(100), unique(name));not null+unique1234567891011============not null+unique============mysql&gt; create table t1(id int not null unique);Query OK, 0 rows affected (0.02 sec)mysql&gt; desc t1;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | |+-------+---------+------+-----+---------+-------+1 row in set (0.00 sec)联合唯一12345678910111213141516171819============ 联合唯一 ============create table service(id int primary key auto_increment,name varchar(20),host varchar(15) not null,port int not null,unique(host,port) #联合唯一);mysql&gt; insert into service values -&gt; (1,&apos;nginx&apos;,&apos;192.168.0.10&apos;,80), -&gt; (2,&apos;haproxy&apos;,&apos;192.168.0.20&apos;,80), -&gt; (3,&apos;mysql&apos;,&apos;192.168.0.30&apos;,3306) -&gt; ;Query OK, 3 rows affected (0.01 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; insert into service(name,host,port) values(&apos;nginx&apos;,&apos;192.168.0.10&apos;,80);ERROR 1062 (23000): Duplicate entry &apos;192.168.0.10-80&apos; for key &apos;host&apos;primary key从约束角度看primary key字段的值不为空且唯一，那我们直接使用not null+unique不就可以了吗，要它干什么？主键primary key是innodb存储引擎组织数据的依据，innodb称之为索引组织表，一张表中必须有且只有一个主键。一个表中可以：单列做主键多列做主键（复合主键）单列主键123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051============单列做主键===============#方法一：not null+uniquecreate table department1(id int not null unique, #主键name varchar(20) not null unique,comment varchar(100));mysql&gt; desc department1;+---------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------+--------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(20) | NO | UNI | NULL | || comment | varchar(100) | YES | | NULL | |+---------+--------------+------+-----+---------+-------+rows in set (0.01 sec)#方法二：在某一个字段后用primary keycreate table department2(id int primary key, #主键name varchar(20),comment varchar(100));mysql&gt; desc department2;+---------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------+--------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(20) | YES | | NULL | || comment | varchar(100) | YES | | NULL | |+---------+--------------+------+-----+---------+-------+rows in set (0.00 sec)#方法三：在所有字段后单独定义primary keycreate table department3(id int,name varchar(20),comment varchar(100),constraint pk_name primary key(id); #创建主键并为其命名pk_namemysql&gt; desc department3;+---------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------+--------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(20) | YES | | NULL | || comment | varchar(100) | YES | | NULL | |+---------+--------------+------+-----+---------+-------+rows in set (0.01 sec)多列主键12345678910111213141516171819202122232425262728==================多列做主键================create table service(ip varchar(15),port char(5),service_name varchar(10) not null,primary key(ip,port));mysql&gt; desc service;+--------------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------------+-------------+------+-----+---------+-------+| ip | varchar(15) | NO | PRI | NULL | || port | char(5) | NO | PRI | NULL | || service_name | varchar(10) | NO | | NULL | |+--------------+-------------+------+-----+---------+-------+rows in set (0.00 sec)mysql&gt; insert into service values -&gt; ('172.16.45.10','3306','mysqld'), -&gt; ('172.16.45.11','3306','mariadb') -&gt; ;Query OK, 2 rows affected (0.00 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; insert into service values ('172.16.45.10','3306','nginx');ERROR 1062 (23000): Duplicate entry '172.16.45.10-3306' for key 'PRIMARY'auto_increment约束字段为自动增长，被约束的字段必须同时被key约束12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#不指定id，则自动增长create table student(id int primary key auto_increment,name varchar(20),sex enum('male','female') default 'male');mysql&gt; desc student;+-------+-----------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-----------------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(20) | YES | | NULL | || sex | enum('male','female') | YES | | male | |+-------+-----------------------+------+-----+---------+----------------+mysql&gt; insert into student(name) values -&gt; ('mark'), -&gt; ('jack') -&gt; ;mysql&gt; select * from student;+----+------+------+| id | name | sex |+----+------+------+| 1 | mark | male || 2 | jack | male |+----+------+------+#也可以指定idmysql&gt; insert into student values(4,'asb','female');Query OK, 1 row affected (0.00 sec)mysql&gt; insert into student values(7,'wsb','female');Query OK, 1 row affected (0.00 sec)mysql&gt; select * from student;+----+------+--------+| id | name | sex |+----+------+--------+| 1 | mark | male || 2 | jack | male || 4 | asb | female || 7 | wsb | female |+----+------+--------+#对于自增的字段，在用delete删除后，再插入值，该字段仍按照删除前的位置继续增长mysql&gt; delete from student;Query OK, 4 rows affected (0.00 sec)mysql&gt; select * from student;Empty set (0.00 sec)mysql&gt; insert into student(name) values('ysb');mysql&gt; select * from student;+----+------+------+| id | name | sex |+----+------+------+| 8 | ysb | male |+----+------+------+#应该用truncate清空表，比起delete一条一条地删除记录，truncate是直接清空表，在删除大表时用它mysql&gt; truncate student;Query OK, 0 rows affected (0.01 sec)mysql&gt; insert into student(name) values('mark');Query OK, 1 row affected (0.01 sec)mysql&gt; select * from student;+----+------+------+| id | name | sex |+----+------+------+| 1 | mark | male |+----+------+------+row in set (0.00 sec)了解知识12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#在创建完表后，修改自增字段的起始值mysql&gt; create table student( -&gt; id int primary key auto_increment, -&gt; name varchar(20), -&gt; sex enum('male','female') default 'male' -&gt; );mysql&gt; alter table student auto_increment=3;mysql&gt; show create table student;.......ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mysql&gt; insert into student(name) values('jack');Query OK, 1 row affected (0.01 sec)mysql&gt; select * from student;+----+------+------+| id | name | sex |+----+------+------+| 3 | jack | male |+----+------+------+row in set (0.00 sec)mysql&gt; show create table student;.......ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8#也可以创建表时指定auto_increment的初始值，注意初始值的设置为表选项，应该放到括号外create table student(id int primary key auto_increment,name varchar(20),sex enum('male','female') default 'male')auto_increment=3;#设置步长sqlserver：自增步长 基于表级别 create table t1（ id int。。。 ）engine=innodb,auto_increment=2 步长=2 default charset=utf8mysql自增的步长： show session variables like 'auto_inc%'; #基于会话级别 set session auth_increment_increment=2 #修改会话级别的步长 #基于全局级别的 set global auth_increment_increment=2 #修改全局级别的步长（所有会话都生效）#！！！注意了注意了注意了！！！If the value of auto_increment_offset is greater than that of auto_increment_increment, the value of auto_increment_offset is ignored. 翻译：如果auto_increment_offset的值大于auto_increment_increment的值，则auto_increment_offset的值会被忽略 ，这相当于第一步步子就迈大了。比如：设置auto_increment_offset=3，auto_increment_increment=2mysql&gt; set global auto_increment_increment=5;Query OK, 0 rows affected (0.00 sec)mysql&gt; set global auto_increment_offset=3;Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like 'auto_incre%'; #需要退出重新登录+--------------------------+-------+| Variable_name | Value |+--------------------------+-------+| auto_increment_increment | 5 || auto_increment_offset | 3 |+--------------------------+-------+create table student(id int primary key auto_increment,name varchar(20),sex enum('male','female') default 'male');mysql&gt; insert into student(name) values('jack1'),('jack2'),('jack3');mysql&gt; select * from student;+----+-------+------+| id | name | sex |+----+-------+------+| 3 | jack1 | male || 8 | jack2 | male || 13 | jack3 | male |+----+-------+------+步长:auto_increment_increment起始偏移量:auto_increment_offsetforeign keyforeign key 案例员工信息表有三个字段：工号 姓名 部门公司有3个部门，但是有1个亿的员工，那意味着部门这个字段需要重复存储，部门名字越长，越浪费解决方法：定义一个部门表然后让员工信息表关联该表，如何关联，即foreign key123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112一： 先建被关联的表,并且保证被关联的字段唯一，一般为 idcreate table dep( id int primary key, name char(16), comment char(50));二： 再建立关联的表(同步更新，同步删除)create table emp( id int primary key, name char(10), sex enum('male','female'), dep_id int, foreign key(dep_id) references dep(id) on delete cascade on update cascade);注意：下面三行没有逗号mysql&gt; desc emp;+--------+-----------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-----------------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | char(10) | YES | | NULL | || sex | enum('male','female') | YES | | NULL | || dep_id | int(11) | YES | MUL | NULL | |+--------+-----------------------+------+-----+---------+-------+4 rows in set (0.00 sec)mysql&gt; desc dep;+---------+----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------+----------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | char(16) | YES | | NULL | || comment | char(50) | YES | | NULL | |+---------+----------+------+-----+---------+-------+3 rows in set (0.00 sec)三： 先往被关联表插入记录insert into dep values(1,"IT","技术部门"),(2,"销售","销售部门"),(3,"财务","财务部门");四：再往关联表插入记录insert into emp values(1,'mark','male',1),(2,'jack','male',1),(3,'wang','female',2),(4,'li','male',3),(5,'liu','male',2);mysql&gt; select * from dep;+----+----------+-----------+| id | name | comment |+----+----------+-----------+| 1 | IT | 技术部门 || 2 | 销售 | 销售部门 || 3 | 财务 | 财务部门 |+----+----------+------- ---+3 rows in set (0.01 sec)mysql&gt; select * from emp;+----+------------+--------+--------+| id | name | sex | dep_id |+----+------------+--------+--------+| 1 | mark | male | 1 || 2 | jack | male | 1 || 3 | wang | female | 2 || 4 | li | male | 3 || 5 | liu | male | 2 |+----+------------+--------+--------+5 rows in set (0.00 sec)删除 dep 表中记录， emp 表中的对应关联的记录会跟着删除mysql&gt; delete from dep where id=2;Query OK, 1 row affected (0.01 sec)mysql&gt; select * from emp;+----+------------+------+--------+| id | name | sex | dep_id |+----+------------+------+--------+| 1 | mark | male | 1 || 2 | jack | male | 1 || 4 | li | male | 3 |+----+------------+------+--------+3 rows in set (0.00 sec)更新 dep 中的记录，emp 表中的记录会跟着改mysql&gt; update dep set id=1111 where id =1;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from emp;+----+------------+------+--------+| id | name | sex | dep_id |+----+------------+------+--------+| 1 | mark | male | 1111 || 2 | jack | male | 1111 || 4 | li | male | 3 |+----+------------+------+--------+3 rows in set (0.00 sec)找出两张表之间的关系1234567891011121314151617分析步骤：#1、先站在左表的角度去找是否左表的多条记录可以对应右表的一条记录，如果是，则证明左表的一个字段foreign key 右表一个字段（通常是id）#2、再站在右表的角度去找是否右表的多条记录可以对应左表的一条记录，如果是，则证明右表的一个字段foreign key 左表一个字段（通常是id）#3、总结：#多对一：如果只有步骤1成立，则是左表多对一右表如果只有步骤2成立，则是右表多对一左表#多对多如果步骤1和2同时成立，则证明这两张表时一个双向的多对一，即多对多,需要定义一个这两张表的关系表来专门存放二者的关系#一对一:如果1和2都不成立，而是左表的一条记录唯一对应右表的一条记录，反之亦然。这种情况很简单，就是在左表foreign key右表的基础上，将左表的外键字段设置成unique即可建立表之间的关系一对多或称为多对一两张表：出版社，书一对多（或多对一）：一个出版社可以出版多本书关联方式：foreign key123456789101112131415161718192021222324252627282930=====================多对一=====================create table press( id int primary key auto_increment, name varchar(20));create table book( id int primary key auto_increment, name varchar(20), press_id int not null, foreign key(press_id) references press(id) on delete cascade on update cascade);insert into press(name) values('北京工业地雷出版社'),('人民音乐不好听出版社'),('知识产权没有用出版社');insert into book(name,press_id) values('九阳神功',1),('九阴真经',2),('九阴白骨爪',2),('独孤九剑',3),('降龙十巴掌',2),('葵花宝典',3);多对多三张表：出版社，作者信息，书多对多：一个作者可以写多本书，一本书也可以有多个作者，双向的一对多，即多对多关联方式：foreign key+一张新的表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364=====================多对多=====================create table author( id int primary key auto_increment, name varchar(20));#这张表就存放作者表与书表的关系，即查询二者的关系查这表就可以了create table author2book( id int not null unique auto_increment, author_id int not null, book_id int not null, constraint fk_author foreign key(author_id) references author(id) on delete cascade on update cascade, foreign key(book_id) references book(id) on delete cascade on update cascade, primary key(author_id,book_id));注意：constraint fk_book 外键别名，可以不写#插入四个作者，id依次排开insert into author(name) values('jack'),('mark'),('wang'),('liu');#每个作者与自己的代表作如下jack: 九阳神功 九阴真经 九阴白骨爪 独孤九剑 降龙十巴掌 葵花宝典mark: 九阳神功 葵花宝典wang: 独孤九剑 降龙十巴掌 葵花宝典liu: 九阳神功insert into author2book(author_id,book_id) values(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,6),(3,4),(3,5),(3,6),(4,1);单张表：用户表+相亲关系表，相当于：用户表+相亲关系表+用户表多张表：用户表+用户与主机关系表+主机表中间那一张存放关系的表，对外关联的字段可以联合唯一一对一两张表：学生表和客户表一对一：一个学生是一个客户，一个客户有可能变成一个学校，即一对一的关系关联方式：foreign key+unique123456789101112131415161718192021222324252627282930313233343536373839#一定是student来foreign key表customer，这样就保证了：#1 学生一定是一个客户，#2 客户不一定是学生，但有可能成为一个学生create table customer( id int primary key auto_increment, name varchar(20) not null, qq varchar(10) not null, phone char(16) not null);create table student( id int primary key auto_increment, class_name varchar(20) not null, customer_id int unique, #该字段一定要是唯一的 foreign key(customer_id) references customer(id) #外键的字段一定要保证unique on delete cascade on update cascade);#增加客户insert into customer(name,qq,phone) values('李飞机','31811231',13811341220),('王大炮','123123123',15213146809),('守榴弹','283818181',1867141331),('吴坦克','283818181',1851143312),('赢火箭','888818181',1861243314),('战地雷','112312312',18811431230);#增加学生insert into student(class_name,customer_id) values('class1',3),('class2',4),('class3',5);练习练习：账号信息表，用户组，主机表，主机组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#用户表create table user( id int not null unique auto_increment, username varchar(20) not null, password varchar(50) not null, primary key(username,password));insert into user(username,password) values('root','123'),('mark','456'),('jack','jack3714');#用户组表create table usergroup( id int primary key auto_increment, groupname varchar(20) not null unique);insert into usergroup(groupname) values('IT'),('Sale'),('Finance'),('boss');#主机表create table host( id int primary key auto_increment, ip char(15) not null unique default '127.0.0.1');insert into host(ip) values('172.16.45.2'),('172.16.31.10'),('172.16.45.3'),('172.16.31.11'),('172.10.45.3'),('172.10.45.4'),('172.10.45.5'),('192.168.1.20'),('192.168.1.21'),('192.168.1.22'),('192.168.2.23'),('192.168.2.223'),('192.168.2.24'),('192.168.3.22'),('192.168.3.23'),('192.168.3.24');#业务线表create table business( id int primary key auto_increment, business varchar(20) not null unique);insert into business(business) values('轻松贷'),('随便花'),('大富翁'),('穷一生');#建关系：user与usergroupcreate table user2usergroup( id int not null unique auto_increment, user_id int not null, group_id int not null, primary key(user_id,group_id), foreign key(user_id) references user(id), foreign key(group_id) references usergroup(id));insert into user2usergroup(user_id,group_id) values(1,1),(1,2),(1,3),(1,4),(2,3),(2,4),(3,4);#建关系：host与businesscreate table host2business( id int not null unique auto_increment, host_id int not null, business_id int not null, primary key(host_id,business_id), foreign key(host_id) references host(id), foreign key(business_id) references business(id));insert into host2business(host_id,business_id) values(1,1),(1,2),(1,3),(2,2),(2,3),(3,4);#建关系：user与hostcreate table user2host( id int not null unique auto_increment, user_id int not null, host_id int not null, primary key(user_id,host_id), foreign key(user_id) references user(id), foreign key(host_id) references host(id));insert into user2host(user_id,host_id) values(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),(1,13),(1,14),(1,15),(1,16),(2,2),(2,3),(2,4),(2,5),(3,10),(3,11),(3,12);]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据操作-数据的增删改查]]></title>
    <url>%2Fposts%2Fa2b7c880%2F</url>
    <content type="text"><![CDATA[MySQL目录数据操作-数据的增删改查数据操作-单表查询数据操作-多表查询数据操作-关键字执行优先级本章简介DML介绍插入数据更新数据删除数据查询数据授权表DML介绍数据操纵语言：DML在MySQL管理软件中，可以通过SQL语句中的DML语言来实现数据的操作，包括：使用INSERT实现数据的插入UPDATE实现数据的更新使用DELETE实现数据的删除使用SELECT查询数据以及。插入数据插入完整数据（顺序插入）12语法一：INSERT INTO 表名(字段1,字段2,字段3…字段n) VALUES(值1,值2,值3…值n);语法二：INSERT INTO 表名 VALUES (值1,值2,值3…值n);指定字段插入数据1语法：INSERT INTO 表名(字段1,字段2,字段3…) VALUES (值1,值2,值3…);插入多条记录1234INSERT INTO 表名 VALUES (值1,值2,值3…值n), (值1,值2,值3…值n), (值1,值2,值3…值n);插入查询结果1INSERT INTO 表名(字段1,字段2,字段3…字段n) SELECT (字段1,字段2,字段3…字段n) FROM 表2 WHERE …;更新数据语法1234UPDATE 表名 SET 字段1=值1, 字段2=值2, WHERE CONDITION;示例1UPDATE mysql.user SET password=password(‘123’) where user=’root’ and host=’localhost’;删除数据语法1DELETE FROM 表名 WHERE CONITION;示例1DELETE FROM mysql.user WHERE password=’’;查询数据【传送门】– 单表查询【传送门】– 关键字执行优先级【传送门】– 多表查询授权表user 该表放行的权限，针对：所有数据，所有库下所有表，以及表下的所有字段db 该表放行的权限，针对：某一数据库，该数据库下的所有表，以及表下的所有字段tables_priv 该表放行的权限。针对：某一张表，以及该表下的所有字段columns_priv 该表放行的权限，针对：某一个字段]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据操作-单表查询]]></title>
    <url>%2Fposts%2Fa6a9d9ad%2F</url>
    <content type="text"><![CDATA[MySQL目录数据操作-数据的增删改查数据操作-单表查询数据操作-多表查询数据操作-关键字执行优先级本章简介单表查询的语法关键字的执行优先级(重点)简单查询WHERE约束分组查询 GROUP BY什么是分组？为什么要分组？ONLY_FULL_GROUP_BYGROUP BY聚合函数练习HAVING过滤查询排序 ORDER BY限制查询的记录数 LIMIT使用正则表达式查询单表查询的语法123456SELECT 字段1,字段2... FROM 表名 WHERE 条件 GROUP BY field HAVING 筛选 ORDER BY field LIMIT 限制条数关键字的执行优先级(重点)123456789101112131415161718fromwheregroup byhavingselectdistinctorder bylimit描述：1.找到表:from2.拿着where指定的约束条件，去文件/表中取出一条条记录3.将取出的一条条记录进行分组group by，如果没有group by，则整体作为一组4.将分组的结果进行having过滤5.执行select6.去重7.将结果按条件排序：order by8.限制结果的显示条数【传送门】-关键字执行优先级简单查询准备表和记录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100company.employee 员工id id int 姓名 emp_name varchar 性别 sex enum 年龄 age int 入职日期 hire_date date 岗位 post varchar 职位描述 post_comment varchar 薪水 salary double 办公室 office int 部门编号 depart_id int# 创建员工表：employeecreate table employee( id int not null unique auto_increment, name varchar(20) not null, sex enum('male','female') not null default 'male', #大部分是男的 age int(3) unsigned not null default 28, hire_date date not null, post varchar(50), post_comment varchar(100), salary double(15,2), office int, #一个部门一个办公室 depart_id int);# 查看表结构mysql&gt; desc employee;+--------------+-----------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------------+-----------------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(20) | NO | | NULL | || sex | enum('male','female') | NO | | male | || age | int(3) unsigned | NO | | 28 | || hire_date | date | NO | | NULL | || post | varchar(50) | YES | | NULL | || post_comment | varchar(100) | YES | | NULL | || salary | double(15,2) | YES | | NULL | || office | int(11) | YES | | NULL | || depart_id | int(11) | YES | | NULL | |+--------------+-----------------------+------+-----+---------+----------------+10 rows in set (0.01 sec)# 插入记录## 三个部门：IT，销售，运营insert into employee(name,sex,age,hire_date,post,salary,office,depart_id) values('mark','male',18,'20170301','网管',7300.33,401,1), #以下是教学部('jack','male',78,'20150302','IT',1000000.31,401,1),('tom','male',81,'20130305','IT',8300,401,1),('sam','male',73,'20140701','IT',3500,401,1),('wang','male',28,'20121101','IT',2100,401,1),('liliang','female',18,'20110211','IT',9000,401,1),('zhang','male',18,'19000301','IT',30000,401,1),('liming','male',48,'20101111','IT',10000,401,1),('aa','female',48,'20150311','sale',3000.13,402,2),#以下是销售部门('bb','female',38,'20101101','sale',2000.35,402,2),('cc','female',18,'20110312','sale',1000.37,402,2),('dd','female',18,'20160513','sale',3000.29,402,2),('ee','female',28,'20170127','sale',4000.33,402,2),('小王','male',28,'20160311','operation',10000.13,403,3), #以下是运营部门('小伟','male',18,'19970312','operation',20000,403,3),('小明','female',18,'20130311','operation',19000,403,3),('大壮','male',18,'20150411','operation',18000,403,3),('明海','female',18,'20140512','operation',17000,403,3);&gt; ps：如果在windows系统中，插入中文字符，select的结果为空白，可以将所有字符编码统一设置成gbkmysql&gt; select * from employee;+----+---------+--------+-----+------------+-----------+--------------+------------+--------+-----------+| id | name | sex | age | hire_date | post | post_comment | salary | office | depart_id |+----+---------+--------+-----+------------+-----------+--------------+------------+--------+-----------+| 1 | mark | male | 18 | 2017-03-01 | 网管 | NULL | 7300.33 | 401 | 1 || 2 | jack | male | 78 | 2015-03-02 | IT | NULL | 1000000.31 | 401 | 1 || 3 | tom | male | 81 | 2013-03-05 | IT | NULL | 8300.00 | 401 | 1 || 4 | sam | male | 73 | 2014-07-01 | IT | NULL | 3500.00 | 401 | 1 || 5 | wang | male | 28 | 2012-11-01 | IT | NULL | 2100.00 | 401 | 1 || 6 | liliang | female | 18 | 2011-02-11 | IT | NULL | 9000.00 | 401 | 1 || 7 | zhang | male | 18 | 1900-03-01 | IT | NULL | 30000.00 | 401 | 1 || 8 | liming | male | 48 | 2010-11-11 | IT | NULL | 10000.00 | 401 | 1 || 9 | aa | female | 48 | 2015-03-11 | sale | NULL | 3000.13 | 402 | 2 || 10 | bb | female | 38 | 2010-11-01 | sale | NULL | 2000.35 | 402 | 2 || 11 | cc | female | 18 | 2011-03-12 | sale | NULL | 1000.37 | 402 | 2 || 12 | dd | female | 18 | 2016-05-13 | sale | NULL | 3000.29 | 402 | 2 || 13 | ee | female | 28 | 2017-01-27 | sale | NULL | 4000.33 | 402 | 2 || 14 | 小王 | male | 28 | 2016-03-11 | operation | NULL | 10000.13 | 403 | 3 || 15 | 小伟 | male | 18 | 1997-03-12 | operation | NULL | 20000.00 | 403 | 3 || 16 | 小明 | female | 18 | 2013-03-11 | operation | NULL | 19000.00 | 403 | 3 || 17 | 大壮 | male | 18 | 2015-04-11 | operation | NULL | 18000.00 | 403 | 3 || 18 | 明海 | female | 18 | 2014-05-12 | operation | NULL | 17000.00 | 403 | 3 |+----+---------+--------+-----+------------+-----------+--------------+------------+--------+-----------+18 rows in set (0.00 sec)简单查询12345SELECT id,name,sex,age,hire_date,post,post_comment,salary,office,depart_id FROM employee;SELECT * FROM employee;SELECT name,salary FROM employee;避免重复DISTINCT12345678910mysql&gt; select distinct post from employee; +-----------+| post |+-----------+| 网管 || IT || sale || operation |+-----------+4 rows in set (0.01 sec)通过四则运算查询123SELECT name, salary*12 FROM employee;SELECT name, salary*12 AS Annual_salary FROM employee;SELECT name, salary*12 Annual_salary FROM employee;AS Annual_salary 是为”新字段”salary*12 定义的别名定义显示格式1234567891011121314151617181920212223242526272829303132333435363738394041424344# CONCAT() 函数用于连接字符串SELECT CONCAT('姓名: ',name,' 年薪: ', salary*12) AS Annual_salary FROM employee;# CONCAT_WS() 第一个参数为分隔符SELECT CONCAT_WS(':',name,salary*12) AS Annual_salary FROM employee;# 结合CASE语句：SELECT ( CASE WHEN NAME = 'mark' THEN NAME WHEN NAME = 'jack' THEN CONCAT(name,'_BIGSB') ELSE concat(NAME, 'SB') END ) as new_nameFROM employee;执行结果：+------------+| new_name |+------------+| mark || jack_BIGSB || tomSB || samSB || wangSB || liliangSB || zhangSB || limingSB || aaSB || bbSB || ccSB || ddSB || eeSB || 小王SB || 小伟SB || 小明SB || 大壮SB || 明海SB |+------------+小练习查出所有员工的名字，薪资,格式为：&lt;姓名：user&gt; &lt;薪资:3000&gt;查出所有的岗位（去掉重复）查出所有员工名字，以及他们的年薪,年薪的字段名为annual_yearWHERE 约束where字句中可以使用比较运算符：&gt; &lt; &gt;= &lt;= &lt;&gt; !=between 80 and 100 值在10到20之间in(80,90,100) 值是10或20或30like ‘wang%’pattern可以是 % 或 _% 表示任意多字符_ 表示一个字符逻辑运算符：在多个条件直接可以使用逻辑运算符 and or not单条件查询1SELECT name FROM employee WHERE post='sale';多条件查询1SELECT name,salary FROM employee WHERE post='IT' AND salary&gt;10000;关键字BETWEEN AND12345SELECT name,salary FROM employee WHERE salary BETWEEN 10000 AND 20000;SELECT name,salary FROM employee WHERE salary NOT BETWEEN 10000 AND 20000;关键字IS NULL(判断某个字段是否为NULL不能用等号，需要用IS)123456789101112SELECT name,post_comment FROM employee WHERE post_comment IS NULL;SELECT name,post_comment FROM employee WHERE post_comment IS NOT NULL; SELECT name,post_comment FROM employee WHERE post_comment=''; 注意''是空字符串，不是nullps： 执行 update employee set post_comment='' where id=2; 再用上条查看，就会有结果了关键字IN集合查询12345678SELECT name,salary FROM employee WHERE salary=3000 OR salary=3500 OR salary=4000 OR salary=9000 ;SELECT name,salary FROM employee WHERE salary IN (3000,3500,4000,9000) ;SELECT name,salary FROM employee WHERE salary NOT IN (3000,3500,4000,9000) ;关键字LIKE模糊查询1234567通配符’%’ 匹配所有SELECT * FROM employee WHERE name LIKE 'ma%';通配符’_’ 匹配单个SELECT * FROM employee WHERE name LIKE 'ma__';分组查询 GROUP BY什么是分组？为什么要分组？首先明确一点：分组发生在where之后，即分组是基于where之后得到的记录而进行的分组指的是：将所有记录按照某个相同字段进行归类，比如针对员工信息表的职位分组，或者按照性别进行分组等大前提：可以按照任意字段分组，但是分组完毕后，比如group by post，只能查看post字段，如果想查看组内信息，需要借助于聚合函数例如：取每个部门的最高工资取每个部门的员工数取男人数和女人数小窍门：‘每’这个字后面的字段，就是我们分组的依据ONLY_FULL_GROUP_BYSQL_MODE设置12345678910#查看MySQL 5.7默认的sql_mode如下：mysql&gt; select @@global.sql_mode;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION#！！！注意ONLY_FULL_GROUP_BY的语义就是确定select target list中的所有列的值都是明确语义，简单的说来，在ONLY_FULL_GROUP_BY模式下，target list中的值要么是来自于聚集函数的结果，要么是来自于group by list中的表达式的值。#设置sql_mole如下操作(我们可以去掉ONLY_FULL_GROUP_BY模式)：mysql&gt; set global sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';练习123456789101112131415161718192021set global sql_mode='ONLY_FULL_GROUP_BY';# 设置好之后需要出去重新登录# 由于没有设置ONLY_FULL_GROUP_BY,于是也可以有结果，默认都是组内的第一条记录，但其实这是没有意义的;而且只能查看分组依据和使用聚合函数mysql&gt; select * from employee group by post;ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'company.employee.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_bymysql&gt; select post,count(id) from employee group by post;+-----------+-----------+| post | count(id) |+-----------+-----------+| IT | 7 || operation | 5 || sale | 5 || 网管 | 1 |+-----------+-----------+4 rows in set (0.01 sec)# 改回原来的配置set global sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';GROUP BY12345678910单独使用GROUP BY关键字分组 SELECT post FROM employee GROUP BY post; 注意：我们按照post字段分组，那么select查询的字段只能是post(默认排序的第一条记录)，想要获取组内的其他相关信息，需要借助函数GROUP BY关键字和GROUP_CONCAT()函数一起使用 SELECT post,GROUP_CONCAT(name) FROM employee GROUP BY post;#按照岗位分组，并查看组内成员名 SELECT post,GROUP_CONCAT(name) as emp_members FROM employee GROUP BY post;GROUP BY与聚合函数一起使用 select post,count(id) as count from employee group by post;#按照岗位分组，并查看每个组有多少人如果我们用unique的字段作为分组的依据，则每一条记录自成一组，这种分组没有意义多条记录之间的某个字段值相同，该字段通常用来作为分组的依据聚合函数12345678910#强调：聚合函数聚合的是组的内容，若是没有分组，则默认一组示例： SELECT COUNT(*) FROM employee; SELECT COUNT(*) FROM employee WHERE depart_id=1; SELECT MAX(salary) FROM employee; SELECT MIN(salary) FROM employee; SELECT AVG(salary) FROM employee; SELECT SUM(salary) FROM employee; SELECT SUM(salary) FROM employee WHERE depart_id=3;练习查询岗位名以及岗位包含的所有员工名字查询岗位名以及各岗位内包含的员工个数查询公司内男员工和女员工的个数查询岗位名以及各岗位的平均薪资查询岗位名以及各岗位的最高薪资查询岗位名以及各岗位的最低薪资查询男员工与男员工的平均薪资，女员工与女员工的平均薪资参考答案12345671 select post,group_concat(name) from employee group by post;2 select post,count(id) from employee group by post;3 select sex,count(id) from employee group by sex;4 select post,avg(salary) from employee group by post;5 select post,max(salary) from employee group by post;6 select post,min(salary) from employee group by post;7 select sex,avg(salary) from employee group by sex;HAVING 过滤HAVING与WHERE区别执行优先级从高到低：where &gt; group by &gt; havingWhere 发生在分组group by之前，因而Where中可以有任意字段，但是绝对不能使用聚合函数。Having发生在分组group by之后，因而Having中可以使用分组的字段，无法直接取到其他字段,可以使用聚合函数练习查询各岗位内包含的员工个数小于2的岗位名、岗位内包含员工名字、个数查询各岗位平均薪资大于10000的岗位名、平均工资查询各岗位平均薪资大于10000且小于20000的岗位名、平均工资123456789101112131415161718192021222324252627281. 查询各岗位内包含的员工个数小于2的岗位名、岗位内包含员工名字、个数mysql&gt; select post,group_concat(name),count(id) from employee group by post having count(id) &lt; 7;+-----------+------------------------------------+-----------+| post | group_concat(name) | count(id) |+-----------+------------------------------------+-----------+| operation | 小王,小伟,小明,大壮,明海 | 5 || sale | aa,bb,cc,dd,ee | 5 || 网管 | mark | 1 |+-----------+------------------------------------+-----------+2. 查询各岗位平均薪资大于10000的岗位名、平均工资mysql&gt; select post,avg(salary) from employee group by post having avg(salary)&gt;10000;+-----------+---------------+| post | avg(salary) |+-----------+---------------+| IT | 151842.901429 || operation | 16800.026000 |+-----------+---------------+3. 查询各岗位平均薪资大于10000且小于20000的岗位名、平均工资mysql&gt; select post,avg(salary) from employee group by post having avg(salary)&gt;10000 and avg(salary)&lt;20000;+-----------+--------------+| post | avg(salary) |+-----------+--------------+| operation | 16800.026000 |+-----------+--------------+查询排序 ORDER BY123456789按单列排序 SELECT * FROM employee ORDER BY salary; # 默认就是升序排列 asc SELECT * FROM employee ORDER BY salary ASC; SELECT * FROM employee ORDER BY salary DESC;按多列排序:先按照age排序，如果年纪相同，则按照薪资排序 SELECT * from employee ORDER BY age, salary DESC;练习查询所有员工信息，先按照age升序排序，如果age相同则按照hire_date降序排序查询各岗位平均薪资大于10000的岗位名、平均工资,结果按平均薪资升序排列查询各岗位平均薪资大于10000的岗位名、平均工资,结果按平均薪资降序排列1234567891011121314151617181920211. 查询所有员工信息，先按照age升序排序，如果age相同则按照hire_date降序排序mysql&gt; select * from employee order by age ,hire_date desc;2. 查询各岗位平均薪资大于10000的岗位名、平均工资,结果按平均薪资升序排列mysql&gt; select post,avg(salary) from employee group by post having avg(salary)&gt;10000 order by avg(salary) asc;+-----------+---------------+| post | avg(salary) |+-----------+---------------+| operation | 16800.026000 || IT | 151842.901429 |+-----------+---------------+3. 查询各岗位平均薪资大于10000的岗位名、平均工资,结果按平均薪资降序排列mysql&gt; select post,avg(salary) from employee group by post having avg(salary) &gt; 10000 order by avg(salary) desc;+-----------+---------------+| post | avg(salary) |+-----------+---------------+| IT | 151842.901429 || operation | 16800.026000 |+-----------+---------------+限制查询的记录数 LIMIT123456789示例： SELECT * FROM employee ORDER BY salary DESC LIMIT 3; #默认初始位置为0 SELECT * FROM employee ORDER BY salary DESC LIMIT 0,5; #从第0开始，即先查询出第一条，然后包含这一条在内往后查5条 SELECT * FROM employee ORDER BY salary DESC LIMIT 5,5; #从第5开始，即先查询出第6条，然后包含这一条在内往后查5条练习：分页查询12345678910mysql&gt; select * from employee order by salary desc limit 0,5;+----+--------+--------+-----+------------+-----------+--------------+------------+--------+-----------+| id | name | sex | age | hire_date | post | post_comment | salary | office | depart_id |+----+--------+--------+-----+------------+-----------+--------------+------------+--------+-----------+| 2 | jack | male | 78 | 2015-03-02 | IT | | 1000000.31 | 401 | 1 || 7 | zhang | male | 18 | 1900-03-01 | IT | NULL | 30000.00 | 401 | 1 || 15 | 小伟 | male | 18 | 1997-03-12 | operation | NULL | 20000.00 | 403 | 3 || 16 | 小明 | female | 18 | 2013-03-11 | operation | NULL | 19000.00 | 403 | 3 || 17 | 大壮 | male | 18 | 2015-04-11 | operation | NULL | 18000.00 | 403 | 3 |+----+--------+--------+-----+------------+-----------+--------------+------------+--------+-----------+一般不会单独是用limit进行分页，会结合缓存等使用正则表达式查询菜鸟教程,正则表达式12345678SELECT * FROM employee WHERE name REGEXP '^ja';SELECT * FROM employee WHERE name REGEXP 'ck$';SELECT * FROM employee WHERE name REGEXP 'm&#123;2&#125;';小结：对字符串匹配的方式WHERE name = 'jack';WHERE name LIKE 'ja%';WHERE name REGEXP 'ck$';1234567891011121314151617181920mysql&gt; select * from employee where name regexp '^ja';+----+------+------+-----+------------+------+--------------+------------+--------+-----------+| id | name | sex | age | hire_date | post | post_comment | salary | office | depart_id |+----+------+------+-----+------------+------+--------------+------------+--------+-----------+| 2 | jack | male | 78 | 2015-03-02 | IT | | 1000000.31 | 401 | 1 |+----+------+------+-----+------------+------+--------------+------------+--------+-----------+mysql&gt; select * from employee where name regexp 'ck$';+----+------+------+-----+------------+------+--------------+------------+--------+-----------+| id | name | sex | age | hire_date | post | post_comment | salary | office | depart_id |+----+------+------+-----+------------+------+--------------+------------+--------+-----------+| 2 | jack | male | 78 | 2015-03-02 | IT | | 1000000.31 | 401 | 1 |+----+------+------+-----+------------+------+--------------+------------+--------+-----------+mysql&gt; select * from employee where name regexp 'a&#123;2&#125;';+----+------+--------+-----+------------+------+--------------+---------+--------+-----------+| id | name | sex | age | hire_date | post | post_comment | salary | office | depart_id |+----+------+--------+-----+------------+------+--------------+---------+--------+-----------+| 9 | aa | female | 48 | 2015-03-11 | sale | NULL | 3000.13 | 402 | 2 |+----+------+--------+-----+------------+------+--------------+---------+--------+-----------+练习查看所有员工中名字是li开头，n或者g结尾的员工信息1234567mysql&gt; select * from employee where name regexp '^li.*(g|n)$' ;+----+---------+--------+-----+------------+------+--------------+----------+--------+-----------+| id | name | sex | age | hire_date | post | post_comment | salary | office | depart_id |+----+---------+--------+-----+------------+------+--------------+----------+--------+-----------+| 6 | liliang | female | 18 | 2011-02-11 | IT | NULL | 9000.00 | 401 | 1 || 8 | liming | male | 48 | 2010-11-11 | IT | NULL | 10000.00 | 401 | 1 |+----+---------+--------+-----+------------+------+--------------+----------+--------+-----------+]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据操作-多表查询]]></title>
    <url>%2Fposts%2Faa733372%2F</url>
    <content type="text"><![CDATA[MySQL目录数据操作-数据的增删改查数据操作-单表查询数据操作-多表查询数据操作-关键字执行优先级本章简介准备测试表多表连接查询符合条件连接查询子查询综合练习准备测试表部门表与员工表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#建表create table department(id int,name varchar(20) );create table employee(id int primary key auto_increment,name varchar(20),sex enum('male','female') not null default 'male',age int,dep_id int);#插入数据insert into department values(200,'技术'),(201,'人力资源'),(202,'销售'),(203,'运营');insert into employee(name,sex,age,dep_id) values('mark','male',18,200),('jack','female',48,201),('xiaowang','male',38,201),('xiaozhang','female',28,202),('xiaoliiu','male',18,200),('alex','female',18,204);#查看表结构和数据mysql&gt; desc department;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)mysql&gt; desc employee;+--------+-----------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------+-----------------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(20) | YES | | NULL | || sex | enum('male','female') | NO | | male | || age | int(11) | YES | | NULL | || dep_id | int(11) | YES | | NULL | |+--------+-----------------------+------+-----+---------+----------------+5 rows in set (0.00 sec)mysql&gt; select * from department;+------+--------------+| id | name |+------+--------------+| 200 | 技术 || 201 | 人力资源 || 202 | 销售 || 203 | 运营 |+------+--------------+4 rows in set (0.01 sec)mysql&gt; select * from employee;+----+-----------+--------+------+--------+| id | name | sex | age | dep_id |+----+-----------+--------+------+--------+| 1 | mark | male | 18 | 200 || 2 | jack | female | 48 | 201 || 3 | xiaowang | male | 38 | 201 || 4 | xiaozhang | female | 28 | 202 || 5 | xiaoliiu | male | 18 | 200 || 6 | alex | female | 18 | 204 |+----+-----------+--------+------+--------+6 rows in set (0.00 sec)多表连接查询重点：外链接语法123SELECT 字段列表 FROM 表1 INNER|LEFT|RIGHT JOIN 表2 ON 表1.字段 = 表2.字段;交叉连接：不适用任何匹配条件。生成笛卡尔积select * from employee,department;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354mysql&gt; select * from employee,department;+----+-----------+--------+------+--------+------+--------------+| id | name | sex | age | dep_id | id | name |+----+-----------+--------+------+--------+------+--------------+| 1 | mark | male | 18 | 200 | 200 | 技术 || 1 | mark | male | 18 | 200 | 201 | 人力资源 || 1 | mark | male | 18 | 200 | 202 | 销售 || 1 | mark | male | 18 | 200 | 203 | 运营 || 2 | jack | female | 48 | 201 | 200 | 技术 || 2 | jack | female | 48 | 201 | 201 | 人力资源 || 2 | jack | female | 48 | 201 | 202 | 销售 || 2 | jack | female | 48 | 201 | 203 | 运营 || 3 | xiaowang | male | 38 | 201 | 200 | 技术 || 3 | xiaowang | male | 38 | 201 | 201 | 人力资源 || 3 | xiaowang | male | 38 | 201 | 202 | 销售 || 3 | xiaowang | male | 38 | 201 | 203 | 运营 || 4 | xiaozhang | female | 28 | 202 | 200 | 技术 || 4 | xiaozhang | female | 28 | 202 | 201 | 人力资源 || 4 | xiaozhang | female | 28 | 202 | 202 | 销售 || 4 | xiaozhang | female | 28 | 202 | 203 | 运营 || 5 | xiaoliiu | male | 18 | 200 | 200 | 技术 || 5 | xiaoliiu | male | 18 | 200 | 201 | 人力资源 || 5 | xiaoliiu | male | 18 | 200 | 202 | 销售 || 5 | xiaoliiu | male | 18 | 200 | 203 | 运营 || 6 | alex | female | 18 | 204 | 200 | 技术 || 6 | alex | female | 18 | 204 | 201 | 人力资源 || 6 | alex | female | 18 | 204 | 202 | 销售 || 6 | alex | female | 18 | 204 | 203 | 运营 || 7 | mark | male | 18 | 200 | 200 | 技术 || 7 | mark | male | 18 | 200 | 201 | 人力资源 || 7 | mark | male | 18 | 200 | 202 | 销售 || 7 | mark | male | 18 | 200 | 203 | 运营 || 8 | jack | female | 48 | 201 | 200 | 技术 || 8 | jack | female | 48 | 201 | 201 | 人力资源 || 8 | jack | female | 48 | 201 | 202 | 销售 || 8 | jack | female | 48 | 201 | 203 | 运营 || 9 | xiaowang | male | 38 | 201 | 200 | 技术 || 9 | xiaowang | male | 38 | 201 | 201 | 人力资源 || 9 | xiaowang | male | 38 | 201 | 202 | 销售 || 9 | xiaowang | male | 38 | 201 | 203 | 运营 || 10 | xiaozhang | female | 28 | 202 | 200 | 技术 || 10 | xiaozhang | female | 28 | 202 | 201 | 人力资源 || 10 | xiaozhang | female | 28 | 202 | 202 | 销售 || 10 | xiaozhang | female | 28 | 202 | 203 | 运营 || 11 | xiaoliiu | male | 18 | 200 | 200 | 技术 || 11 | xiaoliiu | male | 18 | 200 | 201 | 人力资源 || 11 | xiaoliiu | male | 18 | 200 | 202 | 销售 || 11 | xiaoliiu | male | 18 | 200 | 203 | 运营 || 12 | alex | female | 18 | 204 | 200 | 技术 || 12 | alex | female | 18 | 204 | 201 | 人力资源 || 12 | alex | female | 18 | 204 | 202 | 销售 || 12 | alex | female | 18 | 204 | 203 | 运营 |+----+-----------+--------+------+--------+------+--------------+48 rows in set (0.00 sec)内连接：只取两张表的共同部分(只连接匹配的行)select * from employee inner join department on employee.dep_id = department.id ;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 找两张表共有的部分，相当于利用条件从笛卡尔积结果中筛选出了正确的结果# department没有204这个部门，因而employee表中关于204这条员工信息没有匹配出来mysql&gt; select employee.id,employee.name,employee.age,employee.sex,department.name from employee inner join department on employee.dep_id=department.id; +----+-----------+------+--------+--------------+| id | name | age | sex | name |+----+-----------+------+--------+--------------+| 1 | mark | 18 | male | 技术 || 2 | jack | 48 | female | 人力资源 || 3 | xiaowang | 38 | male | 人力资源 || 4 | xiaozhang | 28 | female | 销售 || 5 | xiaoliiu | 18 | male | 技术 || 7 | mark | 18 | male | 技术 || 8 | jack | 48 | female | 人力资源 || 9 | xiaowang | 38 | male | 人力资源 || 10 | xiaozhang | 28 | female | 销售 || 11 | xiaoliiu | 18 | male | 技术 |+----+-----------+------+--------+--------------+10 rows in set (0.00 sec)# 上述SQL等同于mysql&gt; select * from employee inner join department on employee.dep_id = department.id ;+----+-----------+--------+------+--------+------+--------------+| id | name | sex | age | dep_id | id | name |+----+-----------+--------+------+--------+------+--------------+| 1 | mark | male | 18 | 200 | 200 | 技术 || 2 | jack | female | 48 | 201 | 201 | 人力资源 || 3 | xiaowang | male | 38 | 201 | 201 | 人力资源 || 4 | xiaozhang | female | 28 | 202 | 202 | 销售 || 5 | xiaoliiu | male | 18 | 200 | 200 | 技术 || 7 | mark | male | 18 | 200 | 200 | 技术 || 8 | jack | female | 48 | 201 | 201 | 人力资源 || 9 | xiaowang | male | 38 | 201 | 201 | 人力资源 || 10 | xiaozhang | female | 28 | 202 | 202 | 销售 || 11 | xiaoliiu | male | 18 | 200 | 200 | 技术 |+----+-----------+--------+------+--------+------+--------------+10 rows in set (0.00 sec)mysql&gt; select employee.id,employee.name,employee.age,employee.sex,department.name from employee,department where employee.dep_id=department.id; +----+-----------+------+--------+--------------+| id | name | age | sex | name |+----+-----------+------+--------+--------------+| 1 | mark | 18 | male | 技术 || 2 | jack | 48 | female | 人力资源 || 3 | xiaowang | 38 | male | 人力资源 || 4 | xiaozhang | 28 | female | 销售 || 5 | xiaoliiu | 18 | male | 技术 || 7 | mark | 18 | male | 技术 || 8 | jack | 48 | female | 人力资源 || 9 | xiaowang | 38 | male | 人力资源 || 10 | xiaozhang | 28 | female | 销售 || 11 | xiaoliiu | 18 | male | 技术 |+----+-----------+------+--------+--------------+10 rows in set (0.00 sec)左连接:在内连接的基础上保留左表的记录select * from employee left join department on employee.dep_id = department.id ;1234567891011121314151617mysql&gt; select * from employee left join department on employee.dep_id = department.id ; +----+-----------+--------+------+--------+------+--------------+| id | name | sex | age | dep_id | id | name |+----+-----------+--------+------+--------+------+--------------+| 1 | mark | male | 18 | 200 | 200 | 技术 || 5 | xiaoliiu | male | 18 | 200 | 200 | 技术 || 7 | mark | male | 18 | 200 | 200 | 技术 || 11 | xiaoliiu | male | 18 | 200 | 200 | 技术 || 2 | jack | female | 48 | 201 | 201 | 人力资源 || 3 | xiaowang | male | 38 | 201 | 201 | 人力资源 || 8 | jack | female | 48 | 201 | 201 | 人力资源 || 9 | xiaowang | male | 38 | 201 | 201 | 人力资源 || 4 | xiaozhang | female | 28 | 202 | 202 | 销售 || 10 | xiaozhang | female | 28 | 202 | 202 | 销售 || 6 | alex | female | 18 | 204 | NULL | NULL || 12 | alex | female | 18 | 204 | NULL | NULL |+----+-----------+--------+------+--------+------+--------------+12 rows in set (0.00 sec)右连接：在内连接的基础上保留右表的记录select * from employee right join department on employee.dep_id = department.id ;1234567891011121314151617mysql&gt; select * from employee right join department on employee.dep_id = department.id;+------+-----------+--------+------+--------+------+--------------+| id | name | sex | age | dep_id | id | name |+------+-----------+--------+------+--------+------+--------------+| 1 | mark | male | 18 | 200 | 200 | 技术 || 2 | jack | female | 48 | 201 | 201 | 人力资源 || 3 | xiaowang | male | 38 | 201 | 201 | 人力资源 || 4 | xiaozhang | female | 28 | 202 | 202 | 销售 || 5 | xiaoliiu | male | 18 | 200 | 200 | 技术 || 7 | mark | male | 18 | 200 | 200 | 技术 || 8 | jack | female | 48 | 201 | 201 | 人力资源 || 9 | xiaowang | male | 38 | 201 | 201 | 人力资源 || 10 | xiaozhang | female | 28 | 202 | 202 | 销售 || 11 | xiaoliiu | male | 18 | 200 | 200 | 技术 || NULL | NULL | NULL | NULL | NULL | 203 | 运营 |+------+-----------+--------+------+--------+------+--------------+11 rows in set (0.00 sec)全外连接：在内连接的基础上保留左右两表没有对应关系的记录全外连接：在内连接的基础上增加左边有右边没有的和右边有左边没有的结果注意：mysql不支持全外连接 full JOIN强调：mysql可以使用此种方式间接实现全外连接select from employee left join department on employee.dep_id = department.idunionselect from employee right join department on employee.dep_id = department.id;12345678910111213141516171819202122mysql&gt; select * from employee left join department on employee.dep_id = department.id -&gt; union -&gt; select * from employee right join department on employee.dep_id = department.id -&gt; ;+------+-----------+--------+------+--------+------+--------------+| id | name | sex | age | dep_id | id | name |+------+-----------+--------+------+--------+------+--------------+| 1 | mark | male | 18 | 200 | 200 | 技术 || 5 | xiaoliiu | male | 18 | 200 | 200 | 技术 || 7 | mark | male | 18 | 200 | 200 | 技术 || 11 | xiaoliiu | male | 18 | 200 | 200 | 技术 || 2 | jack | female | 48 | 201 | 201 | 人力资源 || 3 | xiaowang | male | 38 | 201 | 201 | 人力资源 || 8 | jack | female | 48 | 201 | 201 | 人力资源 || 9 | xiaowang | male | 38 | 201 | 201 | 人力资源 || 4 | xiaozhang | female | 28 | 202 | 202 | 销售 || 10 | xiaozhang | female | 28 | 202 | 202 | 销售 || 6 | alex | female | 18 | 204 | NULL | NULL || 12 | alex | female | 18 | 204 | NULL | NULL || NULL | NULL | NULL | NULL | NULL | 203 | 运营 |+------+-----------+--------+------+--------+------+--------------+13 rows in set (0.00 sec)注意 union与union all的区别：union会去掉相同的纪录符合条件连接查询示例1：以内连接的方式查询employee和department表，并且employee表中的age字段值必须大于25,即找出年龄大于25岁的员工以及员工所在的部门123select employee.name,department.name from employee inner join department on employee.dep_id = department.id where age &gt; 25;1234567891011121314mysql&gt; select employee.name,department.name from employee inner join department -&gt; on employee.dep_id = department.id -&gt; where age &gt; 25;+-----------+--------------+| name | name |+-----------+--------------+| jack | 人力资源 || xiaowang | 人力资源 || jack | 人力资源 || xiaowang | 人力资源 || xiaozhang | 销售 || xiaozhang | 销售 |+-----------+--------------+6 rows in set (0.01 sec)示例2：以内连接的方式查询employee和department表，并且以age字段的升序方式显示1234select employee.id,employee.name,employee.age,department.name from employee,department where employee.dep_id = department.id and age &gt; 25 order by age asc;123456789101112131415mysql&gt; select employee.id,employee.name,employee.age,department.name from employee,department -&gt; where employee.dep_id = department.id -&gt; and age &gt; 25 -&gt; order by age asc;+----+-----------+------+--------------+| id | name | age | name |+----+-----------+------+--------------+| 4 | xiaozhang | 28 | 销售 || 10 | xiaozhang | 28 | 销售 || 3 | xiaowang | 38 | 人力资源 || 9 | xiaowang | 38 | 人力资源 || 2 | jack | 48 | 人力资源 || 8 | jack | 48 | 人力资源 |+----+-----------+------+--------------+6 rows in set (0.00 sec)子查询综合练习]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库概述]]></title>
    <url>%2Fposts%2Fdfdfdf4%2F</url>
    <content type="text"><![CDATA[MySQL目录数据库简介-数据库概述数据库简介-MySQL基本管理本章简介数据(Data)数据库(DataBase，简称DB)数据库管理系统数据库服务器、数据管理系统、数据库、表与记录数据库管理技术的发展历程在编写任何程序之前，都需要事先写好基于网络操作一台主机上文件的程序（socket服务端与客户端程序），于是有人将此类程序写成一个专门的处理软件，这就是mysql等数据库管理软件的由来，但mysql解决的不仅仅是数据共享的问题，还有查询效率，安全性等一系列问题，总之，把程序员从数据管理中解脱出来，专注于自己的程序逻辑的编写。数据(Data)描述事物的符号记录称为数据，描述事物的符号既可以是数字，也可以是文字、图片，图像、声音、语言等，数据由多种表现形式，它们都可以经过数字化后存入计算机。在计算机中描述一个事物，就需要抽取这一事物的典型特征，组成一条记录，就相当于文件里的一行内容数据库(DataBase，简称DB)数据库即存放数据的仓库，只不过这个仓库是在计算机存储设备上，而且数据是按一定的格式存放的。数据库是长期存放在计算机内、有组织、可共享的数据。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。数据库管理系统(DataBase Management System 简称DBMS)在了解了Data与DB的概念后，如何科学地组织和存储数据，如何高效获取和维护数据成了关键。这就用到了一个系统软件—数据库管理系统。如MySQL、Oracle、SQLite、Access、MS SQL ServerMySQL主要用于大型门户，例如搜狗、新浪等，它主要的优势就是开放源代码，因为开放源代码这个数据库是免费的，他现在是甲骨文公司的产品。Oracle 主要用于银行、铁路、飞机场等。该数据库功能强大，软件费用高。也是甲骨文公司的产品。SQLServer 是微软公司的产品，主要应用于大中型企业，如联想、方正等。数据库服务器、数据管理系统、数据库、表与记录数据库服务器：运行数据库管理软件数据库管理软件：管理-数据库数据库：即文件夹，用来组织文件/表表：即文件，用来存放多行内容/多条记录数据库管理技术的发展历程人工管理阶段数据不保存：计算机主要用于科学计算，数据临时用，临时输入，不保存应用程序管理数据：数据要有应用程序自己管理，应用程序需要处理数据的逻辑+物理结构，开发负担很重数据不共享：一组数据只对应一个程序，多个程序之间涉及相同数据时，必须各自定义，造成数据大量冗余数据不具有独立性：数据的逻辑结构或物理结构发生变化后，必须对应用程序做出相应的修改，开发负担进一步加大文件系统阶段优点:数据可以长期保存;由文件系统管理数据缺点:数据共享性差，冗余度大;数据独立性差数据系统阶段数据结构化数据共享，冗余度低，易扩充数据独立性高数据由DBMS统一管理和控制数据的安全性保护数据的完整性检查并发控制数据库恢复]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据操作-关键字执行优先级]]></title>
    <url>%2Fposts%2Fe3a606b7%2F</url>
    <content type="text"><![CDATA[MySQL目录数据操作-数据的增删改查数据操作-单表查询数据操作-多表查询数据操作-关键字执行优先级本章简介SELECT语句关键字的定义顺序SELECT语句关键字的执行顺序准备表和数据准备SQL逻辑查询测试语句执行顺序分析SELECT语句关键字的定义顺序123456789SELECT DISTINCT &lt;select_list&gt;FROM &lt;left_table&gt;&lt;join_type&gt; JOIN &lt;right_table&gt;ON &lt;join_condition&gt;WHERE &lt;where_condition&gt;GROUP BY &lt;group_by_list&gt;HAVING &lt;having_condition&gt;ORDER BY &lt;order_by_condition&gt;LIMIT &lt;limit_number&gt;SELECT语句关键字的执行顺序SELECTDISTINCT &lt;select_list&gt;FROM &lt;left_table&gt;&lt;join_type&gt; JOIN &lt;right_table&gt;ON &lt;join_condition&gt;WHERE &lt;where_condition&gt;GROUP BY &lt;group_by_list&gt;HAVING &lt;having_condition&gt;ORDER BY &lt;order_by_condition&gt;LIMIT &lt;limit_number&gt;准备表和数据新建一个测试数据库1create database db2 charset='utf8';创建测试表table1和table2123456789101112131415use db2;CREATE TABLE table1 ( customer_id VARCHAR(10) NOT NULL, city VARCHAR(10) NOT NULL, PRIMARY KEY(customer_id) )ENGINE=INNODB DEFAULT CHARSET=UTF8; CREATE TABLE table2 ( order_id INT NOT NULL auto_increment, customer_id VARCHAR(10), PRIMARY KEY(order_id) )ENGINE=INNODB DEFAULT CHARSET=UTF8;插入测试数据123456789101112INSERT INTO table1(customer_id,city) VALUES('163','hangzhou');INSERT INTO table1(customer_id,city) VALUES('9you','shanghai');INSERT INTO table1(customer_id,city) VALUES('tx','hangzhou');INSERT INTO table1(customer_id,city) VALUES('baidu','hangzhou');INSERT INTO table2(customer_id) VALUES('163');INSERT INTO table2(customer_id) VALUES('163');INSERT INTO table2(customer_id) VALUES('9you');INSERT INTO table2(customer_id) VALUES('9you');INSERT INTO table2(customer_id) VALUES('9you');INSERT INTO table2(customer_id) VALUES('tx');INSERT INTO table2(customer_id) VALUES(NULL);确认插入结果123456789101112131415161718192021222324mysql&gt; select * from table1;+-------------+----------+| customer_id | city |+-------------+----------+| 163 | hangzhou || 9you | shanghai || baidu | hangzhou || tx | hangzhou |+-------------+----------+4 rows in set (0.00 sec)mysql&gt; select * from table2;+----------+-------------+| order_id | customer_id |+----------+-------------+| 1 | 163 || 2 | 163 || 3 | 9you || 4 | 9you || 5 | 9you || 6 | tx || 7 | NULL |+----------+-------------+7 rows in set (0.00 sec)准备SQL逻辑查询测试语句查询来自杭州，并且订单数少于2的客户12345678SELECT a.customer_id, COUNT(b.order_id) as total_orders FROM table1 AS a LEFT JOIN table2 AS b ON a.customer_id = b.customer_id WHERE a.city = 'hangzhou' GROUP BY a.customer_id HAVING count(b.order_id) &lt; 2 ORDER BY total_orders DESC;执行顺序分析]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基本管理]]></title>
    <url>%2Fposts%2Fdc6e92b4%2F</url>
    <content type="text"><![CDATA[MySQL目录数据库简介-数据库概述数据库简介-MySQL基本管理本章简介MySQL安装Linux版本Window版本登录，设置密码MySQL基本管理登录，设置密码linux平台下，破解密码的两种方式windows平台下，破解密码的两种方式在windows下，为mysql服务指定配置文件统一字符编码初识SQL语句MySQL安装MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发。MySQL 最流行的关系型数据库管理系统，在 WEB 应用方面MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。数据库管理软件分类分两大类：关系型：如sqllite，db2，oracle，access，sql server，MySQL。(注意：sql语句通用)非关系型：mongodb，redis，memcache简单的理解为：关系型数据库需要有表结构非关系型数据库是key-value存储的，没有表结构Linux版本yum 安装1yum -y install mysql-server mysql源码安装MySQL1234567891011121314151617181920212223242526272829303132333435363738394041421.解压tar包cd /softwaretar -xzvf mysql-5.6.21-linux-glibc2.5-x86_64.tar.gzmv mysql-5.6.21-linux-glibc2.5-x86_64 mysql-5.6.212.添加用户与组groupadd mysqluseradd -r -g mysql mysqlchown -R mysql:mysql mysql-5.6.213.安装数据库su mysqlcd mysql-5.6.21/scripts./mysql_install_db --user=mysql --basedir=/software/mysql-5.6.21 --datadir=/software/mysql-5.6.21/data4.配置文件cd /software/mysql-5.6.21/support-filescp my-default.cnf /etc/my.cnfcp mysql.server /etc/init.d/mysqlvim /etc/init.d/mysql #若mysql的安装目录是/usr/local/mysql,则可省略此步修改文件中的两个变更值basedir=/software/mysql-5.6.21datadir=/software/mysql-5.6.21/data5.配置环境变量vim /etc/profileexport MYSQL_HOME="/software/mysql-5.6.21"export PATH="$PATH:$MYSQL_HOME/bin"source /etc/profile6.添加自启动服务chkconfig --add mysqlchkconfig mysql on7.启动mysqlservice mysql start8.登录mysql及改密码与配置远程访问mysqladmin -u root password 'your_password'mysql -u root -pmysql&gt;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'your_password' WITH GRANT OPTION; #允许root用户远程访问mysql&gt;FLUSH PRIVILEGES; #刷新授权源码安装mariadb1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950511. 解压tar zxvf mariadb-5.5.31-linux-x86_64.tar.gz mv mariadb-5.5.31-linux-x86_64 /usr/local/mysql //必需这样，很多脚本或可执行程序都会直接访问这个目录2. 权限groupadd mysql //增加 mysql 属组 useradd -g mysql mysql //增加 mysql 用户 并归于mysql 属组 chown mysql:mysql -Rf /usr/local/mysql // 设置 mysql 目录的用户及用户组归属。 chmod +x -Rf /usr/local/mysql //赐予可执行权限 3. 拷贝配置文件cp /usr/local/mysql/support-files/my-medium.cnf /etc/my.cnf //复制默认mysql配置 文件到/etc目录 4. 初始化/usr/local/mysql/scripts/mysql_install_db --user=mysql //初始化数据库 cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql //复制mysql服务程序 到系统目录 chkconfig mysql on //添加mysql 至系统服务并设置为开机启动 service mysql start //启动mysql5. 环境变量配置vim /etc/profile //编辑profile,将mysql的可执行路径加入系统PATHexport PATH=/usr/local/mysql/bin:$PATH source /etc/profile //使PATH生效。6. 账号密码mysqladmin -u root password &apos;yourpassword&apos; //设定root账号及密码mysql -u root -p //使用root用户登录mysqluse mysql //切换至mysql数据库。select user,host,password from user; //查看系统权限drop user &apos;&apos;@&apos;localhost&apos;; //删除不安全的账户drop user root@&apos;::1&apos;;drop user root@127.0.0.1;select user,host,password from user; //再次查看系统权限，确保不安全的账户均被删除。flush privileges; //刷新权限7. 一些必要的初始配置1）修改字符集为UTF8vi /etc/my.cnf在[client]下面添加 default-character-set = utf8在[mysqld]下面添加 character_set_server = utf82）增加错误日志vi /etc/my.cnf在[mysqld]下面添加：log-error = /usr/local/mysql/log/error.loggeneral-log-file = /usr/local/mysql/log/mysql.log3) 设置为不区分大小写，linux下默认会区分大小写。vi /etc/my.cnf在[mysqld]下面添加：lower_case_table_name=1修改完重启：#service mysql restartWindow版本安装12345678910111213141516171、下载：MySQL Community Server 5.7.16http://dev.mysql.com/downloads/mysql/2、解压如果想要让MySQL安装在指定目录，那么就将解压后的文件夹移动到指定目录，如：C:\mysql-5.7.16-winx643、添加环境变量【右键计算机】--》【属性】--》【高级系统设置】--》【高级】--》【环境变量】--》【在第二个内容框中找到 变量名为Path 的一行，双击】 --&gt; 【将MySQL的bin目录路径追加到变值值中，用 ； 分割】4、初始化mysqld --initialize-insecure5、启动MySQL服务mysqld # 启动MySQL服务6、启动MySQL客户端并连接MySQL服务mysql -u root -p # 连接MySQL服务器将MySQL服务制作成windows服务上一步解决了一些问题，但不够彻底，因为在执行【mysqd】启动MySQL服务器时，当前终端会被夯住，那么做一下设置即可解决此问题,即将MySQL服务制作成windows服务1234567891011121314注意：--install前，必须用mysql启动命令的绝对路径# 制作MySQL的Windows服务，在终端执行此命令：&quot;c:\mysql-5.7.16-winx64\bin\mysqld&quot; --install# 移除MySQL的Windows服务，在终端执行此命令：&quot;c:\mysql-5.7.16-winx64\bin\mysqld&quot; --remove注册成服务之后，以后再启动和关闭MySQL服务时，仅需执行如下命令：# 启动MySQL服务net start mysql# 关闭MySQL服务net stop mysqlMySQL基本管理登录，设置密码12mysqladmin -uroot password "123" 设置初始密码 由于原密码为空，因此-p可以不用mysqladmin -uroot -p"123" password "456" 修改mysql密码,linux平台下，破解密码的两种方式方法一：启动时，跳过授权库1234567891011[root@mark ~]# vim /etc/my.cnf #mysql主配置文件[mysqld]skip-grant-table[root@mark ~]# systemctl restart mariadb[root@mark ~]# mysqlMariaDB [(none)]&gt; update mysql.user set password=password("123") where user="root" and host="localhost";MariaDB [(none)]&gt; flush privileges;MariaDB [(none)]&gt; \q[root@mark ~]# #打开/etc/my.cnf去掉skip-grant-table,然后重启[root@mark ~]# systemctl restart mariadb[root@mark ~]# mysql -u root -p123 #以新密码登录方法二：删除授权库mysql，重新初始化(慎用)123# rm -rf /var/lib/mysql/mysql #所有授权信息全部丢失！！！# systemctl restart mariadb# mysqlwindows平台下，破解密码的两种方式5.7版本mysql方式一123456789#1 关闭mysql#2 在cmd中执行：mysqld --skip-grant-tables#3 在cmd中执行：mysql#4 执行如下sql：update mysql.user set authentication_string=password('') where user = 'root';flush privileges;#5 tskill mysqld #或taskkill -f /PID 7832#6 重新启动mysql方式二12345678910111213#1. 关闭mysql，可以用tskill mysqld将其杀死#2. 在解压目录下，新建mysql配置文件my.ini#3. my.ini内容,指定[mysqld]skip-grant-tables#4.启动mysqld#5.在cmd里直接输入mysql登录，然后操作update mysql.user set authentication_string=password('') where user='root and host='localhost';flush privileges;#6.注释my.ini中的skip-grant-tables，然后启动myqsld，然后就可以以新密码登录了在windows下，为mysql服务指定配置文件强调：配置文件中的注释可以有中文，但是配置项中不能出现中文my.ini123456789101112131415161718192021222324252627282930#在mysql的解压目录下，新建my.ini,然后配置#1. 在执行mysqld命令时，下列配置会生效，即mysql服务启动时生效[mysqld];skip-grant-tablesport=3306character_set_server=utf8default-storage-engine=innodbinnodb_file_per_table=1#解压的目录basedir=E:\mysql-5.7.19-winx64#data目录datadir=E:\my_data #在mysqld --initialize时，就会将初始数据存入此处指定的目录，在初始化之后，启动mysql时，就会去这个目录里找数据#2. 针对客户端命令的全局配置，当mysql客户端命令执行时，下列配置生效[client]port=3306default-character-set=utf8user=rootpassword=123#3. 只针对mysql这个客户端的配置，2中的是全局配置，而此处的则是只针对mysql这个命令的局部配置[mysql];port=3306;default-character-set=utf8user=markpassword=4573#！！！如果没有[mysql],则用户在执行mysql命令时的配置以[client]为准统一字符编码123456789101112131415161718192021222324252627282930313233343536#1. 修改配置文件[mysqld]default-character-set=utf8 [client]default-character-set=utf8 [mysql]default-character-set=utf8#mysql5.5以上：修改方式有所改动[mysqld]character-set-server=utf8collation-server=utf8_general_ci[client]default-character-set=utf8[mysql]default-character-set=utf8#2. 重启服务#3. 查看修改结果：mysql&gt; \s # 不要加分号mysql&gt; show variables like '%char%';+--------------------------+---------------------------------------------------------+| Variable_name | Value |+--------------------------+---------------------------------------------------------+| character_set_client | latin1 || character_set_connection | latin1 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | latin1 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/local/mysql-5.7.12-osx10.11-x86_64/share/charsets/ |+--------------------------+---------------------------------------------------------+8 rows in set (0.00 sec)mysql&gt;初识SQL语句SQL（Structured Query Language 即结构化查询语言）SQL语言主要用于存取数据、查询数据、更新数据和管理关系数据库系统,SQL语言由IBM开发。SQL语言分为3种类型：DDL语句 数据库定义语言： 数据库、表、视图、索引、存储过程，例如CREATE DROP ALTERDML语句 数据库操纵语言： 插入数据INSERT、删除数据DELETE、更新数据UPDATE、查询数据SELECTDCL语句 数据库控制语言： 例如控制用户的访问权限GRANT、REVOKE操作文件夹增：create database db1 charset utf8;查：show databases;改：alter database db1 charset latin1;删: drop database db1;操作文件先切换到文件夹下：use db1增: create table t1(id int,name char);查: show tables;改:alter table t1 modify name char(3);alter table t1 change name name1 char(2);删：drop table t1;操作文件中的内容/记录增：insert into t1 values(1,’mark1’),(2,’mark2’),(3,’mark3’);查：select * from t1;改：update t1 set name=’sb’ where id=2;删：delete from t1 where id=1;清空表：delete from t1; # 如果有自增id，新增的数据，仍然是以删除前的最后一样作为起始。truncate table t1; # 数据量大，删除速度比上一条快，且直接从零开始，auto_increment # 表示：自增primary key # 表示：约束（不能重复且不能为空）；加速查找]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[库的增删改查]]></title>
    <url>%2Fposts%2F40e6f772%2F</url>
    <content type="text"><![CDATA[MySQL目录库操作-库的增删改查本章简介系统数据库创建数据库初识SQL语句数据库相关操作系统数据库information_schema： 虚拟库，不占用磁盘空间，存储的是数据库启动后的一些参数，如用户表信息、列信息、权限信息、字符信息等。performance_schema： MySQL 5.5开始新增一个数据库：主要用于收集数据库服务器性能参数，记录处理查询请求时发生的各种事件、锁等现象 。mysql： 授权库，主要存储系统用户的权限信息test： MySQL数据库系统自动创建的测试数据库创建数据库语法(help create database)CREATE DATABASE 数据库名 charset utf8; 数据库命名规则可以由字母、数字、下划线、＠、＃、＄要区分大小写唯一性不能使用关键字如 create select不能单独使用数字最长128位数据库相关操作查看数据库123show databases;show create database db1;select database();选择数据库1USE 数据库名删除数据库1DROP DATABASE 数据库名;修改数据库1alter database db1 charset utf8;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL目录]]></title>
    <url>%2Fposts%2F53fb2cc8%2F</url>
    <content type="text"><![CDATA[写在前面本教程大量的借鉴了林海峰老师 、菜鸟教程 、MySQL官网 等优秀博客的观点和实例郑重申明：本教程所涉及的示例、操作步骤等均为亲力亲为实验所得，摒弃毫无论据的复制粘贴一 数据库简介数据库简介-数据库概述数据库简介-MySQL基本管理二 库操作库操作-库的增删改查三 表操作表操作-存储引擎介绍表操作-表的增删改查表操作-数据类型表操作-完整性约束四 数据操作数据操作-数据的增删改查数据操作-单表查询数据操作-多表查询数据操作-关键字执行优先级五 客户端工具客户端工具-图形工具Navicat客户端工具-pymysql模式六 内置功能内置功能-视图内置功能-触发器内置功能-事务内置功能-存储过程内置功能-函数内置功能-流程控制七 索引与慢查询索引与慢查询八 MySQL运维MySQL运维-读写分离]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
